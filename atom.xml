<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rayzhang13.github.io</id>
    <title>Ray&apos;s Blog</title>
    <updated>2021-05-29T09:05:00.395Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rayzhang13.github.io"/>
    <link rel="self" href="https://rayzhang13.github.io/atom.xml"/>
    <subtitle>Everything&apos;s gonna be just fine.</subtitle>
    <logo>https://rayzhang13.github.io/images/avatar.png</logo>
    <icon>https://rayzhang13.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Ray&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[A*算法解决八数码问题]]></title>
        <id>https://rayzhang13.github.io/post/eight-digit-maze/</id>
        <link href="https://rayzhang13.github.io/post/eight-digit-maze/">
        </link>
        <updated>2021-05-29T08:24:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<h2 id="八数码问题">八数码问题</h2>
<p>八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤。<br>
所谓问题的一个状态就是棋子在棋盘上的一种摆法。棋子移动后，状态就会发生改变。解八数码问题实际上就是找出从初始状态到达目标状态所经过的一系列中间过渡状态。<br>
<img src="https://rayzhang13.github.io/post-images/1622276905057.jpg" alt="" loading="lazy"></p>
<h2 id="a算法">A*算法</h2>
<p>A*算法是一种启发式搜索算法，启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无谓的搜索路径，提高了效率。</p>
<p>算法核心公式：<br>
F = G + H<br>
F - 决策的总代价<br>
G - 从开始到决策时刻所花费的真实代价<br>
H - 从决策时刻到目标的预估代价</p>
<p>其中G值是一个真实的代价，也就是从算法流程一开始到进行这个决策的时候，一共花费的代价。H值是一个预估的代价。在极端情况下，如果H是常量0，这个算法退化成广度优先搜索算法，即按照顺序的依次扩充每个节点。如果G是常量，这个算法退化成贪心算法，即每次扩充可以使下一次最优的节点。每次进行决策的时候，A*算法选择遍历所有当前可能的决策，并执行使F最大的决策。</p>
<h2 id="策略">策略</h2>
<p>我们定义从开始状态执行的总步数为真实代价G，而当前状态与最终结果的格数差异我们记为H即从决策时刻到目标的预估代价。例如上图所示中的初始状态与最终状态之间相距了5个位置，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">H = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></p>
<h1 id="代码解决">代码解决</h1>
<p>对于八数码问题，我们先考虑到的是如何使用数据结构将各个状态一一对应的表达出来<br>
例如<br>
<img src="https://rayzhang13.github.io/post-images/1622277406237.png" alt="" loading="lazy"></p>
<p>我们看到八数码问题中有9个元素的位置，我们按照行将其标记为0, 1, 2, 3, 4, 5, 6, 7, 8个元素，每个位置的元素n满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">0 \leq n \leq 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，我们定义空位置为0<br>
而最大8的极端情况下其二进制表达为8<sub>D</sub> = (1000)<sub>B</sub>，需要4位的二进制空间，则9个元素总共需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>∗</mo><mn>9</mn><mo>=</mo><mn>36</mn></mrow><annotation encoding="application/x-tex">4 * 9 = 36</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span></span></span></span>位的二进制数来表示一个状态，故我们需要长整型long来进行表示</p>
<p>对于上图其十进制对应状态表达为1 4 2 8 0 3 7 6 5<br>
二进制表达为 0001 0100 0010 1000 0000 0011 0111 0110 0101，记为一个32位的整型</p>
<p>对应A*算法，其本质是一个贪心算法，我们维护一个优先队列pq，每次取出F最小的节点并对其进行拓展，每次取出的节点由贪心可知应为最优解，拓展过程中记得去重</p>
<p><img src="https://rayzhang13.github.io/post-images/1622278983736.png" alt="" loading="lazy"><br>
代码如下：</p>
<pre><code class="language-java">import java.util.Arrays;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Set;

public class grid {
    Set&lt;Long&gt; set = new HashSet&lt;&gt;();
    //为了防止入队时产生的重复情况，采用Set对入队元素进行去重
    int[][] adjacency = {{1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7}}; 
    //adjacency数组用于表示第i个元素若为空，他可以和adjacency[i]内部的元素进行交换
    public long convert(int[] arr){   //将arr数组表示为32位整型long
        long res = 0l;
        for(int i = 0; i &lt; 9; i++){
            res += arr[i] * (1l &lt;&lt; (i * 4));
        }
        return res;
    }
    public int diff(long stat1, long stat2){ 
        //计算stat1与stat2之间的距离差距，用于计算当前状态与目标状态之间的距离H
        int cnt = 0;
        for(int i = 0; i &lt; 9; i++){
            long tmp1 = (stat1 &gt;&gt; (i * 4)) % 16;
            long tmp2 = (stat2 &gt;&gt; (i * 4)) % 16;
            if(tmp1 != tmp2) cnt++;
        }
        return cnt;
    }
    public long swap(long stat, int pos1, int pos2){ 
        //对于状态stat，若pos1所在位置位空（记为0），将其与pos2位置进行交换，并返回新的状态
        long tmp2 = (stat &gt;&gt; (pos2 * 4)) % 16; //取出pos2位置的元素
        stat -= tmp2 * (1l &lt;&lt; (pos2 * 4));  //将pos2对应位置清0
        stat += tmp2 * (1l &lt;&lt; (pos1 * 4));  //将0对应位置填充为pos2原先的值，完成交换
        return stat;
    }
    public int AStarSearch(int[] start, int[] target){
        int zero = -1;
        for(int i = 0; i &lt; 9; i++){
            if(start[i] == 0) zero = i;  //标记start数组中0的位置
        }
        long a = convert(start), b = convert(target); //转换为整型状态
        PriorityQueue&lt;long[]&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; (int) (diff(o1[1], b) + o1[2] - diff(o2[1], b) - o2[2]));
        //pq内部数组定义：{0的位置, 当前状态整型, 真实步数}
        pq.offer(new long[]{zero, a, 0l}); //优先队列加入初始状态
        set.add(a);     //将初始状态加入去重Set
        while(!pq.isEmpty()){
            long[] cur = pq.poll();
            display(cur, b);
            if(cur[1] == b) return (int)cur[2]; //若取出的数组与目标对应，记为结束
            int blank = (int)cur[0];  //当前数组的0所在位置
            for(int x: adjacency[blank]) {
                long n_stat = swap(cur[1], blank, x);  
                //将元素0与其周围元素进行交换，得到新状态
                if (!set.contains(n_stat)) {   //Set去重
                    pq.offer(new long[]{x, n_stat, cur[2] + 1}); //交换后新状态
                    set.add(n_stat);  //新状态加入去重Set
                }
            }
        }
        return -1; //找不到返回-1
    }

    private void display(long[] cur, long target) { //打印数组的相关信息
        int[][] res = new int[3][3];
        long stat = cur[1];
        for(int i = 0; i &lt; 9; i++){
            res[i / 3][i % 3] = (int) (stat % 16);
            stat = stat &gt;&gt; 4;
        }
        for(int[] x: res) System.out.println(Arrays.toString(x)); //打印数组
        System.out.println(&quot;steps: &quot; + cur[2]); //打印当前步数
        System.out.println(&quot;distance: &quot; + diff(cur[1], target)); //打印与目标距离
    }

    public static void main(String[] args) {
        int[] start = new int[]{1, 4, 2, 8, 0, 3, 7, 6, 5};
        int[] target = new int[]{1, 2, 3, 8, 0, 4, 7, 6, 5};
        System.out.println(&quot;\nSTEP: &quot; + new grid().AStarSearch(start, target));
    }
}

</code></pre>
<p>每一轮while循环，程序都将打印出队的cur数组相关信息，最后打印STEP最终步数<br>
运行结果如下：</p>
<pre><code class="language-bash">/Users/ray/Library/Java/JavaVirtualMachines/openjdk-15.0.2/Contents/Home/bin/java -javaagent:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=52037:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/ray/IdeaProjects/oj/out/production/oj com.company.grid
[1, 4, 2]
[8, 0, 3]
[7, 6, 5]
steps: 0
distance: 3
[1, 0, 2]
[8, 4, 3]
[7, 6, 5]
steps: 1
distance: 4
[1, 4, 2]
[8, 3, 0]
[7, 6, 5]
steps: 1
distance: 4
[1, 2, 0]
[8, 4, 3]
[7, 6, 5]
steps: 2
distance: 3
[1, 2, 3]
[8, 4, 0]
[7, 6, 5]
steps: 3
distance: 2
[1, 2, 3]
[8, 0, 4]
[7, 6, 5]
steps: 4
distance: 0

STEP: 4

Process finished with exit code 0
</code></pre>
<p>我们得到最终步数为4</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hanoi问题]]></title>
        <id>https://rayzhang13.github.io/post/hanoi-problem/</id>
        <link href="https://rayzhang13.github.io/post/hanoi-problem/">
        </link>
        <updated>2021-05-29T07:49:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="起源">起源</h1>
<p>最早发明这个问题的人是法国数学家爱德华·卢卡斯。</p>
<p>传说越南河内某间寺院有三根银棒，上串 64 个金盘。寺院里的僧侣依照一个古老的预言，以上述规则移动这些盘子；预言说当这些盘子移动完毕，世界就会灭亡。这个传说叫做梵天寺之塔问题（Tower of Brahma puzzle）。但不知道是卢卡斯自创的这个传说，还是他受他人启发。<br>
若传说属实，僧侣们需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{64} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>步才能完成这个任务；若他们每秒可完成一个盘子的移动，就需要 5849 亿年才能完成。整个宇宙现在也不过 137 亿年。</p>
<p>这个传说有若干变体：寺院换成修道院、僧侣换成修士等等。寺院的地点众说纷纭，其中一说是位于越南的河内，所以被命名为“河内塔”。另外亦有“金盘是创世时所造”、“僧侣们每天移动一盘”之类的背景设定。</p>
<h1 id="求解思想">求解思想</h1>
<p><img src="https://rayzhang13.github.io/post-images/1622275695419.jpg" alt="" loading="lazy"><br>
解法的基本思想是递归。假设有 A、B、C 三个塔，A 塔有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>块盘，目标是把这些盘全部移到 C 塔。那么先把 A 塔顶部的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>块盘移动到 B 塔，再把 A 塔剩下的大盘移到 C，最后把 B 塔的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>块盘移到 C。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(n) = f(n - 1) * 2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
复杂度应为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>如此递归地使用下去, 就可以求解。</p>
<h1 id="递归解">递归解</h1>
<p>盘子自上到下编号依次为1、2、3 ..... n</p>
<pre><code class="language-java">public class Main {
    public void hanoi(int n, char a, char b, char c){       //目标操作a-&gt;c, 中间变量b
        if(n == 1) System.out.println(&quot;1th plate: &quot; + a + &quot;-&gt;&quot; + c);
        else{
            hanoi(n - 1, a, c, b); //现将1~ n-1从a移到b
            System.out.println(n + &quot;th plate: &quot; + a + &quot;-&gt;&quot; + c); //将n移到c
            hanoi(n - 1, b, a, c); //将1~ n-1从b移到c
        }
    }
    public static void main(String[] args) {
        new Main().hanoi(3, 'a', 'b', 'c');
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-bash">/Users/ray/Library/Java/JavaVirtualMachines/openjdk-15.0.2/Contents/Home/bin/java -javaagent:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=63346:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/ray/IdeaProjects/oj/out/production/oj com.company.Main
1th plate: a-&gt;c
2th plate: a-&gt;b
1th plate: c-&gt;b
3th plate: a-&gt;c
1th plate: b-&gt;a
2th plate: b-&gt;c
1th plate: a-&gt;c

Process finished with exit code 0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode刷题计划]]></title>
        <id>https://rayzhang13.github.io/post/leetcode-project/</id>
        <link href="https://rayzhang13.github.io/post/leetcode-project/">
        </link>
        <updated>2021-05-29T07:02:29.000Z</updated>
        <content type="html"><![CDATA[<p>这是菜鸡的主页<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span>  <a href="https://leetcode-cn.com/u/chmod-r-000-e/">https://leetcode-cn.com/u/chmod-r-000-e/</a><br>
<img src="https://rayzhang13.github.io/post-images/1622271963578.png" alt="" loading="lazy"></p>
<p>从大二下坚持下也快有一年了，期间经历了风风雨雨<br>
可惜我就只顾着刷题了，也没想着做点项目啥的，基础也不扎实，Java写了个寂寞</p>
<p>所以刷题也要适度哦，还有很多别的事情没有完成，不要把刷题当作逃避的借口<br>
万事开头难，共勉！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找的边界问题]]></title>
        <id>https://rayzhang13.github.io/post/BinarySearchOccasions/</id>
        <link href="https://rayzhang13.github.io/post/BinarySearchOccasions/">
        </link>
        <updated>2021-05-28T14:47:13.000Z</updated>
        <content type="html"><![CDATA[<p>我们都知道对于一个单调数组，对其进行二分查找的复杂度一般为O(log N)<br>
通过控制上下界lo和hi不断缩小范围得到<br>
本文将探讨二分搜索中的几种情况</p>
<h1 id="二分查找模版">二分查找模版</h1>
<h2 id="普通二分查找找到目标target即可">普通二分查找（找到目标target即可）</h2>
<pre><code class="language-Java">public class BinarySearch {
    public int search(int[] arr, int target){
        int lo = 0, hi = arr.length - 1;
        while(lo &lt;= hi){
            int mid = lo + (hi - lo) / 2;       //为了防止 (hi + lo) / 2 发生整型溢出
            if(target &gt; arr[mid]) lo = mid + 1;
            else if(target &lt; arr[mid]) hi = mid - 1;
            else return mid;
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{-1, 0, 3, 5, 9, 12};
        System.out.println(new BinarySearch().search(arr, 9));
    }
}
</code></pre>
<p>其中查找区间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mi>o</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[lo, hi]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，即左闭右闭，因此while循环内条件为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mo>≤</mo><mi>h</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">lo \leq hi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span></span></span></span></p>
<ol>
<li>当查询到mid所在下标值为target时停止</li>
<li>若mid所在下表值小于target，则说明目标值在当前区间右半侧，故将闭区间左端点调整为mid + 1<br>
<img src="https://rayzhang13.github.io/post-images/1622221197511.png" alt="too small" loading="lazy"></li>
<li>若mid所在下表值大于target，则说明目标值在当前区间左半侧，故将闭区间左端点调整为mid - 1<br>
<img src="https://rayzhang13.github.io/post-images/1622221348036.png" alt="too large" loading="lazy"></li>
</ol>
<h2 id="二分查找下界">二分查找下界</h2>
<p>例如数组{1, 2, 2, 2, 2, 3, 4, 5}<br>
当查找2时，区间缩小时可能取到下标1, 2, 3, 4任意一点，故需要重新修改边界条件<br>
代码如下:</p>
<pre><code class="language-java">public class BinarySearch {
    public int search(int[] arr, int target){
        int res = -1;
        int lo = 0, hi = arr.length - 1;
        while(lo &lt;= hi){
            int mid = lo + (hi - lo) / 2;
            if(target &gt; arr[mid]) lo = mid + 1;
            else {
                if(arr[mid] == target) res = mid;   //若满足要求提前将res记录
                hi = mid - 1;   //排除当前mid，继续缩小区间
            }
        }
        return res;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{1, 1, 1, 2, 2, 3, 3, 5};
        System.out.println(new BinarySearch().search(arr, 5));
    }
}
</code></pre>
<p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo><mo>≤</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">arr[mid] \leq target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span></p>
<ul>
<li>若小于，则应该缩小上界，继续向下搜索</li>
<li>若等于，则应该首先标记当前mid下标为res，再排除当前mid以后的所有元素，继续尝试向下查找</li>
</ul>
<h2 id="二分查找上界">二分查找上界</h2>
<p>同理，与上方类似<br>
二分下界查找如下：</p>
<pre><code class="language-java">public class BinarySearch {
    public int search(int[] arr, int target){
        int res = -1;
        int lo = 0, hi = arr.length - 1;
        while(lo &lt;= hi){
            int mid = lo + (hi - lo) / 2;
            if(target &lt; arr[mid]) hi = mid - 1;
            else {
                if(arr[mid] == target) res = mid;
                lo = mid + 1;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        int[] arr = new int[]{1, 1, 1, 2, 2, 3, 3, 5};
        System.out.println(new BinarySearch().search(arr, 3));
    }
}
</code></pre>
<h1 id="二分查找例题">二分查找例题</h1>
<h2 id="leetcode-1870-准时到达的列车最小时速-round-242-t2"><a href="https://leetcode-cn.com/problems/minimum-speed-to-arrive-on-time/">leetcode 1870. 准时到达的列车最小时速 Round 242 T2</a></h2>
<p>给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。</p>
<p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p>
<p>例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。<br>
返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。</p>
<p>生成的测试用例保证答案不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> ，且 hour 的 小数点后最多存在两位数字 。</p>
<ul>
<li>
<p>示例 1：<br>
<strong>输入：dist = [1,3,2], hour = 6<br>
输出：1</strong><br>
解释：速度为 1 时：<br>
第 1 趟列车运行需要 1/1 = 1 小时。<br>
由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3/1 = 3 小时。<br>
由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2/1 = 2 小时。<br>
你将会恰好在第 6 小时到达。</p>
</li>
<li>
<p>示例 2：<br>
<strong>输入：dist = [1,3,2], hour = 2.7<br>
输出：3</strong><br>
解释：速度为 3 时：<br>
第 1 趟列车运行需要 1/3 = 0.33333 小时。<br>
由于不是在整数时间到达，故需要等待至第 1 小时才能搭乘列车。第 2 趟列车运行需要 3/3 = 1 小时。<br>
由于是在整数时间到达，可以立即换乘在第 2 小时发车的列车。第 3 趟列车运行需要 2/3 = 0.66667 小时。<br>
你将会在第 2.66667 小时到达。</p>
</li>
<li>
<p>示例 3：<br>
<strong>输入：dist = [1,3,2], hour = 1.9<br>
输出：-1</strong><br>
解释：不可能准时到达，因为第 3 趟列车最早是在第 2 小时发车。</p>
</li>
</ul>
<p>提示：<br>
n == dist.length<br>
1 &lt;= n &lt;= 105<br>
1 &lt;= dist[i] &lt;= 105<br>
1 &lt;= hour &lt;= 109<br>
hours 中，<strong>小数点后最多存在两位数字</strong></p>
<p>我们可以用二分的方法寻找到能够按时到达的最小时速。<br>
由于时速必须为正整数，因此二分的下界为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；对于二分的上界，我们考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">hours</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span></span> 为两位小数，因此对于最后一段路程，最小的时限为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0.01</mn></mrow><annotation encoding="application/x-tex">0.01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，那么最高的时速要求即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">/</mi><mn>0.01</mn><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">dist[i] / 0.01 \leq 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">/</span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> ，同时为二分时速的上界, 即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">dist \leq 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。注意向上取整细节</p>
<pre><code class="language-java">class Solution {
public static int minSpeedOnTime(int[] dist, double hour) {
        if ((((dist[dist.length - 1] * 1.0) / (10000000 * 1.0)) + dist.length - 1) &gt; hour) {
            return -1;
        }
        int left = 1;
        int right = 1000000000;
        int speed = left + (right - left) / 2;
        int result = -1;
        while (left &lt; right) {
            boolean isOk = judge(speed, dist, hour);
            if (isOk) {
                result = result == -1 ? speed : Math.min(result, speed);
                right = speed;
            } else {
                left = speed + 1;
            }
            speed = left + (right - left) / 2;
        }
        if (result != -1) {
            return result;
        }
        boolean isOk = judge(speed, dist, hour);
        if (isOk) {
            return speed;
        } else {
            return -1;
        }
    }
    private static boolean judge(int speed, int[] dist, double hour) {
        double time = 0.0;
        for (int i = 0; i &lt; dist.length - 1; i++) {
            time += ceilDiv(dist[i], speed);
            if (time &gt; hour) {
                continue;
            }
        }
        time += (dist[dist.length - 1] * 1.0) / (speed * 1.0);
        return time &lt;= hour;
    }
    private static int ceilDiv(int a, int b) {
        int temp = Math.floorDiv(a, b);
        if (temp * b &lt; a) {
            return (temp + 1);
        } else {
            return temp;
        }
    }
}
</code></pre>
<h2 id="leetcode-962-最大宽度坡"><a href="https://leetcode-cn.com/problems/maximum-width-ramp/">leetcode 962. 最大宽度坡</a></h2>
<p>给定一个整数数组 A，坡是元组 (i, j)，其中  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \lt j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>≤</mo><mi>A</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[i] \leq A[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>。这样的坡的宽度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。<br>
找出 A 中的坡的最大宽度，如果不存在，返回 0 。</p>
<p>示例 1：<br>
<strong>输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>6</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[6,0,8,2,1,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span><br>
输出：4</strong><br>
解释：<br>
最大宽度的坡为 (i, j) = (1, 5): <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A[1] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>5</mn><mo>]</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">A[5] = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>.</p>
<p>示例 2：<br>
<strong>输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>9</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[9,8,1,0,1,9,4,0,4,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><br>
输出：7</strong><br>
解释：<br>
最大宽度的坡为 (i, j) = (2, 9): <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A[2] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>9</mn><mo>]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A[9] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">9</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.</p>
<p>维护一个max数组，自右向左遍历当前最大元素<br>
再A数组自左向右一次遍历，查询max数组中大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的元素下标的上界，查询后将差与res取大</p>
<pre><code class="language-java">class Solution {
    public int maxWidthRamp(int[] A) {
        int len = A.length;
        int[] max = new int[len];
        int tmp = 0;
        int res = 0;
        for(int i = len - 1; i &gt;= 0; i--){
            tmp = Math.max(tmp, A[i]);
            max[i] = tmp;
        }
        //System.out.println(Arrays.toString(max));
        for(int i = 0 ; i &lt; len; i++){
            int target = search(max, i + 1, A[i]);
            //System.out.println(i + &quot; &quot; + target);
            if(target != -1) res = Math.max(res, target - i);
        }
        return res;
    }
    public int search(int[] arr, int start, int target){
        int lo = start, hi = arr.length - 1;
        int ans = -1;
        while(lo &lt;= hi){
            int mid = lo + (hi - lo) / 2;
            //System.out.println(lo + &quot; &quot; + hi + &quot; &quot; + mid);
            if(arr[mid] &lt; target){
                hi = mid - 1;
            }
            else{
                ans = mid;
                lo = mid + 1;
            }
        }
        return ans;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>