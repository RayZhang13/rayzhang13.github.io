<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rayzhang13.github.io</id>
    <title>Ray&apos;s Blog</title>
    <updated>2021-06-27T06:53:45.511Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rayzhang13.github.io"/>
    <link rel="self" href="https://rayzhang13.github.io/atom.xml"/>
    <subtitle>Everything&apos;s gonna be just fine.</subtitle>
    <logo>https://rayzhang13.github.io/images/avatar.png</logo>
    <icon>https://rayzhang13.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Ray&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode Bio-Weekly Contest Round 55]]></title>
        <id>https://rayzhang13.github.io/post/leetcode-bio-weekly-contest-round-55/</id>
        <link href="https://rayzhang13.github.io/post/leetcode-bio-weekly-contest-round-55/">
        </link>
        <updated>2021-06-27T06:07:40.000Z</updated>
        <summary type="html"><![CDATA[<p>万年三题选手，菜鸡正常水平，t4出了很多问题，现场能过就见鬼了<br>
<img src="https://rayzhang13.github.io/post-images/1624774136156.png" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>万年三题选手，菜鸡正常水平，t4出了很多问题，现场能过就见鬼了<br>
<img src="https://rayzhang13.github.io/post-images/1624774136156.png" alt="" loading="lazy"></p>
<!-- more -->
<h1 id="t1-5780-删除一个元素使数组严格递增">T1 <a href="https://leetcode-cn.com/problems/remove-one-element-to-make-the-array-strictly-increasing/">5780. 删除一个元素使数组严格递增</a></h1>
<h2 id="题目">题目</h2>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果 <strong>恰好</strong> 删除 <strong>一个</strong> 元素后，数组 <strong>严格递增</strong> ，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。如果数组本身已经是严格递增的，请你也返回 <code>true</code> 。</p>
<p>数组 <code>nums</code> 是 <strong>严格递增</strong> 的定义为：对于任意下标的 <code>1 &lt;= i &lt; nums.length</code> 都满足 <code>nums[i - 1] &lt; nums[i]</code> 。</p>
<blockquote>
<p>示例 1：<br>
输入：<code>nums = [1,2,10,5,7]</code><br>
输出：true<br>
解释：从 nums 中删除下标 2 处的 10 ，得到 <code>[1,2,5,7]</code> 。<br>
<code>[1,2,5,7]</code> 是严格递增的，所以返回 true 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：<code>nums = [2,3,1,2]</code><br>
输出：false<br>
解释：<br>
<code>[3,1,2]</code> 是删除下标 0 处元素后得到的结果。<br>
<code>[2,1,2]</code> 是删除下标 1 处元素后得到的结果。<br>
<code>[2,3,2]</code> 是删除下标 2 处元素后得到的结果。<br>
<code>[2,3,1]</code> 是删除下标 3 处元素后得到的结果。<br>
没有任何结果数组是严格递增的，所以返回 false 。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：<code>nums = [1,1,1]</code><br>
输出：false<br>
解释：删除任意元素后的结果都是 <code>[1,1]</code> 。<br>
<code>[1,1]</code> 不是严格递增的，所以返回 false 。</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：<code>nums = [1,2,3]</code><br>
输出：true<br>
解释：<code>[1,2,3]</code> 已经是严格递增的，所以返回 true 。</p>
</blockquote>
<p>提示：<br>
<code>2 &lt;= nums.length &lt;= 1000</code><br>
<code>1 &lt;= nums[i] &lt;= 1000</code></p>
<h2 id="题解">题解</h2>
<p>这复杂度操作空间太大了，leetcode周赛第一题经典有手就行，别多想（<br>
每次去掉一个数，强行遍历即可</p>
<pre><code class="language-java">class Solution {
    public boolean canBeIncreasing(int[] nums) {
        int len = nums.length;
        for(int i = 0; i &lt; len; i++){
            Integer prev = null;
            boolean flag = true;
            for(int j = 0; j &lt; len; j++){
                if(j == i) continue;
                if(prev == null){
                    prev = nums[j];
                    continue;
                }
                if(prev &gt;= nums[j]) {
                    flag = false;
                    break;
                }
                else prev = nums[j];
            }
            if(flag) return true;
        }
        return false;
    }
}
</code></pre>
<h1 id="t2-5781-删除一个字符串中所有出现的给定子字符串">T2 <a href="https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/">5781. 删除一个字符串中所有出现的给定子字符串</a></h1>
<h2 id="题目-2">题目</h2>
<p>给你两个字符串 <code>s</code> 和 <code>part</code> ，请你对 <code>s</code> 反复执行以下操作直到 <strong>所有</strong> 子字符串 <code>part</code> 都被删除：</p>
<ul>
<li>找到 <code>s</code> 中 <strong>最左边</strong> 的子字符串 <code>part</code> ，并将它从 <code>s</code> 中删除。<br>
请你返回从 <code>s</code> 中删除所有 <code>part</code> 子字符串以后得到的剩余字符串。<br>
一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</li>
</ul>
<blockquote>
<p>示例 1：<br>
输入：s = &quot;daabcbaabcbc&quot;, part = &quot;abc&quot;<br>
输出：&quot;dab&quot;<br>
解释：以下操作按顺序执行：<br>
s = &quot;daabcbaabcbc&quot; ，删除下标从 2 开始的 &quot;abc&quot; ，得到 s = &quot;dabaabcbc&quot; 。<br>
s = &quot;dabaabcbc&quot; ，删除下标从 4 开始的 &quot;abc&quot; ，得到 s = &quot;dababc&quot; 。<br>
s = &quot;dababc&quot; ，删除下标从 3 开始的 &quot;abc&quot; ，得到 s = &quot;dab&quot; 。<br>
此时 s 中不再含有子字符串 &quot;abc&quot; 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：s = &quot;axxxxyyyyb&quot;, part = &quot;xy&quot;<br>
输出：&quot;ab&quot;<br>
解释：以下操作按顺序执行：<br>
s = &quot;axxxxyyyyb&quot; ，删除下标从 4 开始的 &quot;xy&quot; ，得到 s = &quot;axxxyyyb&quot; 。<br>
s = &quot;axxxyyyb&quot; ，删除下标从 3 开始的 &quot;xy&quot; ，得到 s = &quot;axxyyb&quot; 。<br>
s = &quot;axxyyb&quot; ，删除下标从 2 开始的 &quot;xy&quot; ，得到 s = &quot;axyb&quot; 。<br>
s = &quot;axyb&quot; ，删除下标从 1 开始的 &quot;xy&quot; ，得到 s = &quot;ab&quot; 。<br>
此时 s 中不再含有子字符串 &quot;xy&quot; 。<br>
 <br>
提示：<br>
1 &lt;= s.length &lt;= 1000<br>
1 &lt;= part.length &lt;= 1000<br>
s​​​​​​ 和 part 只包小写英文字母。</p>
</blockquote>
<h2 id="题解-2">题解</h2>
<p><code>indexOf()</code>方法好啊，虽然<code>indexOf</code>也是通过自左向右遍历暴力实现的（但是可以提升手速</p>
<pre><code class="language-java">class Solution {
    public String removeOccurrences(String s, String part) {
        int len = part.length();
        while(s.indexOf(part) != -1){
            int cur = s.indexOf(part);
            s = s.substring(0, cur) + s.substring(cur + len, s.length());
        }
        return s;
    }
}
</code></pre>
<h1 id="t3-5782-最大子序列交替和">T3 <a href="https://leetcode-cn.com/problems/maximum-alternating-subsequence-sum/">5782. 最大子序列交替和</a></h1>
<h2 id="题目-3">题目</h2>
<p>一个下标从 <strong>0</strong> 开始的数组的 <strong>交替和</strong> 定义为 <strong>偶数</strong> 下标处元素之 <strong>和</strong> 减去 <strong>奇数</strong> 下标处元素之 <strong>和</strong> 。</p>
<p>比方说，数组 <code>[4,2,5,3]</code> 的交替和为 <code>(4 + 5) - (2 + 3) = 4</code> 。<br>
给你一个数组 <code>nums</code> ，请你返回 <code>nums</code> 中任意子序列的 <strong>最大交替和</strong> （子序列的下标 <strong>重新</strong> 从 0 开始编号）。</p>
<p>一个数组的 <strong>子序列</strong> 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,2,3,7,2,1,4]</code> 的一个子序列（加粗元素），但是 <code>[2,4,2]</code> 不是。</p>
<blockquote>
<p>示例 1：<br>
输入：<code>nums = [4,2,5,3]</code><br>
输出：7<br>
解释：最优子序列为 <code>[4,2,5]</code> ，交替和为 (4 + 5) - 2 = 7 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：<code>nums = [5,6,7,8]</code><br>
输出：8<br>
解释：最优子序列为 <code>[8]</code> ，交替和为 8 。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：<code>nums = [6,2,1,2,4,5]</code><br>
输出：10<br>
解释：最优子序列为 <code>[6,1,5]</code> ，交替和为 (6 + 5) - 1 = 10 。<br>
 <br>
提示：<br>
<code>1 &lt;= nums.length &lt;= 10^5</code><br>
<code>1 &lt;= nums[i] &lt;= 10^5</code></p>
</blockquote>
<h2 id="题解-3">题解</h2>
<p>数据量大小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>首先<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>暴力必然会导致TLE<br>
这道题是比较典型的状态转换dp题，我们发现计算交替和的时候，长度为奇数的子数组状态 可以和 长度为偶数的子数组状态 可以互相转换<br>
我们定义：</p>
<ul>
<li>创建<code>dp1</code>数组，其中<code>dp1[i]</code>表示<code>nums</code>数组<code>0 ~ i</code>中可以生成的奇数长度子数组的最大交替和</li>
<li>同理，<code>dp2[i]</code>表示<code>nums</code>数组<code>0 ~ i</code>中可以生成的偶数长度子数组的最大交替和<br>
不难发现，有如下关系，动态规划方程如下：</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mn>1</mn><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mn>1</mn><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mn>2</mn><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] + nums[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mn>2</mn><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mn>2</mn><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mn>1</mn><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp2[i] = Math.max(dp2[i - 1], dp1[i - 1] - nums[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span><br>
注意到，<code>nums.length</code>和<code>nums[i]</code>在最差情况下都可以到达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>的大小，对于<code>int</code>来说存在溢出的风险，可以暂时使用<code>long</code>进行替代存储</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-java">class Solution {
    public long maxAlternatingSum(int[] nums) {
        int len = nums.length;
        long[] dp1 = new long[len];
        long[] dp2 = new long[len];
        dp1[0] = (long)nums[0];
        for(int i = 1; i &lt; len; i++){
            dp1[i] = Math.max((long)dp1[i - 1], (long)dp2[i - 1] + (long)nums[i]);
            dp2[i] = Math.max((long)dp2[i - 1], (long)dp1[i - 1] - (long)nums[i]);
        }
        return dp1[len - 1] &gt; dp2[len - 1] ? dp1[len - 1]: dp2[len - 1];
    }
}
</code></pre>
<h1 id="t4-5783-设计电影租借系统">T4 <a href="https://leetcode-cn.com/problems/design-movie-rental-system/">5783. 设计电影租借系统</a></h1>
<h2 id="题目-4">题目</h2>
<p>你有一个电影租借公司和 <code>n</code> 个电影商店。你想要实现一个电影租借系统，它支持查询、预订和返还电影的操作。同时系统还能生成一份当前被借出电影的报告。</p>
<p>所有电影用二维整数数组 <code>entries</code> 表示，其中 <code>entries[i] = [shopi, moviei, pricei]</code> 表示商店 <code>shopi</code> 有一份电影 <code>moviei</code> 的拷贝，租借价格为 <code>pricei</code> 。每个商店有 <strong>至多一份</strong> 编号为 <code>moviei</code> 的电影拷贝。</p>
<p>系统需要支持以下操作：</p>
<ul>
<li><strong>Search</strong> 找到拥有指定电影且 <strong>未借出</strong> 的商店中 <strong>最便宜的 5 个</strong> 。商店需要按照 <strong>价格</strong> 升序排序，如果价格相同，则 <code>shopi</code> <strong>较小</strong> 的商店排在前面。如果查询结果少于 5 个商店，则将它们全部返回。如果查询结果没有任何商店，则返回空列表。</li>
<li><strong>Rent</strong> 从指定商店借出指定电影，题目保证指定电影在指定商店 <strong>未借出</strong> 。</li>
<li><strong>Drop</strong> 在指定商店返还 <strong>之前已借出</strong> 的指定电影。</li>
<li><strong>Report</strong> 返回 <strong>最便宜的 5 部已借出电影</strong> （可能有重复的电影 ID），将结果用二维列表 <code>res</code> 返回，其中 <code>res[j] = [shopj, moviej]</code> 表示第 <code>j</code> 便宜的已借出电影是从商店 <code>shopj</code> 借出的电影 <code>moviej</code> 。<code>res</code> 中的电影需要按 <strong>价格</strong> 升序排序；如果价格相同，则 <code>shopj</code> <strong>较小</strong> 的排在前面；如果仍然相同，则 <code>moviej</code> <strong>较小</strong> 的排在前面。如果当前借出的电影小于 5 部，则将它们全部返回。如果当前没有借出电影，则返回一个空的列表。</li>
</ul>
<p>请你实现 MovieRentingSystem 类：</p>
<ul>
<li><code>MovieRentingSystem(int n, int[][] entries)</code> 将 <code>MovieRentingSystem</code> 对象用 <code>n</code> 个商店和 <code>entries</code> 表示的电影列表初始化。</li>
<li><code>List&lt;Integer&gt; search(int movie)</code> 如上所述，返回 <strong>未借出</strong> 指定 <code>movie</code> 的商店列表。</li>
<li><code>void rent(int shop, int movie)</code> 从指定商店 <code>shop</code> 借出指定电影 <code>movie</code> 。</li>
<li><code>void drop(int shop, int movie)</code> 在指定商店 <code>shop</code> 返还之前借出的电影 <code>movie</code> 。</li>
<li><code>List&lt;List&lt;Integer&gt;&gt; report()</code> 如上所述，返回最便宜的 **已借出 **电影列表。<br>
<strong>注意</strong> 测试数据保证 <code>rent</code> 操作中指定商店拥有 <strong>未借出</strong> 的指定电影，且 <code>drop</code> 操作指定的商店 <strong>之前已借出</strong> 指定电影。</li>
</ul>
<blockquote>
<p>示例 1：<br>
输入：<br>
<code>[&quot;MovieRentingSystem&quot;, &quot;search&quot;, &quot;rent&quot;, &quot;rent&quot;, &quot;report&quot;, &quot;drop&quot;, &quot;search&quot;]</code><br>
<code>[[3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]], [1], [0, 1], [1, 2], [], [1, 2], [2]]</code><br>
输出：<br>
<code>[null, [1, 0, 2], null, null, [[0, 1], [1, 2]], null, [0, 1]]</code><br>
解释：<br>
<code>MovieRentingSystem movieRentingSystem = new MovieRentingSystem(3, [[0, 1, 5], [0, 2, 6], [0, 3, 7], [1, 1, 4], [1, 2, 7], [2, 1, 5]]);</code><br>
<code>movieRentingSystem.search(1);</code>  // 返回 <code>[1, 0, 2]</code> ，商店 1，0 和 2 有未借出的 ID 为 1 的电影。商店 1 最便宜，商店 0 和 2 价格相同，所以按商店编号排序。<br>
<code>movieRentingSystem.rent(0, 1);</code> // 从商店 0 借出电影 1 。现在商店 0 未借出电影编号为 <code>[2,3]</code> 。<br>
<code>movieRentingSystem.rent(1, 2);</code> // 从商店 1 借出电影 2 。现在商店 1 未借出的电影编号为 <code>[1]</code> 。<br>
<code>movieRentingSystem.report();</code>   // 返回 <code>[[0, 1], [1, 2]]</code> 。商店 0 借出的电影 1 最便宜，然后是商店 1 借出的电影 2 。<br>
<code>movieRentingSystem.drop(1, 2);</code> // 在商店 1 返还电影 2 。现在商店 1 未借出的电影编号为 <code>[1,2]</code> 。<br>
<code>movieRentingSystem.search(2);</code>  // 返回 <code>[0, 1]</code> 。商店 0 和 1 有未借出的 ID 为 2 的电影。商店 0 最便宜，然后是商店 1 。</p>
</blockquote>
<p>提示：<br>
<code>1 &lt;= n &lt;= 3 * 10^5</code><br>
<code>1 &lt;= entries.length &lt;= 10^5</code><br>
<code>0 &lt;= shopi &lt; n</code><br>
<code>1 &lt;= moviei, pricei &lt;= 10^4</code><br>
每个商店 <strong>至多</strong> 有一份电影 moviei 的拷贝。<br>
search，rent，drop 和 report 的调用 <strong>总共</strong> 不超过 10^5 次。</p>
<h2 id="题解-4">题解</h2>
<p>大型阅读理解现场，读得死去活来，题目不难，关键是自己犯了点错误<br>
代码如下：</p>
<pre><code class="language-java">class MovieRentingSystem {
    Map&lt;Integer,PriorityQueue&lt;int[]&gt;&gt;movies=new HashMap&lt;&gt;();
    Set&lt;int[]&gt;set=new HashSet&lt;&gt;();
    PriorityQueue&lt;int[]&gt;jie=new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() {
        @Override
        public int compare(int[] o1, int[] o2) {
            if(o1[2]!=o2[2])return o1[2]-o2[2];
            else if(o1[1]!=o2[1])return o1[1]-o2[1];
            else return o1[0]-o2[0];
        }
    });
    Map&lt;Integer,int[]&gt;[]shops;
    public MovieRentingSystem(int n, int[][] entries) {
        shops=new Map[n];
        for(int i=0;i&lt;n;i++)
            shops[i]=new HashMap();
        for(int i=0;i&lt;entries.length;i++)
        {
            int[]tem=entries[i];
            if(movies.get(tem[1])==null)movies.put(tem[1],new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() {
                @Override
                public int compare(int[] o1, int[] o2) {
                    if(o1[2]!=o2[2])
                        return o1[2]-o2[2];
                    else return o1[0]-o2[0];
                }
            }));
            movies.get(tem[1]).add(tem);
            shops[tem[0]].put(tem[1],tem);
        }
    }
    public List&lt;Integer&gt; search(int movie) {
        int num=5;
        List&lt;Integer&gt;list=new ArrayList&lt;&gt;();
        if(movies.get(movie)==null)return list;
        PriorityQueue&lt;int[]&gt;tem=(movies.get(movie));
        Stack&lt;int[]&gt;stack=new Stack&lt;&gt;();
        while (!tem.isEmpty()&amp;&amp;num&gt;0)
        {
            int[]arr=tem.poll();
            stack.add(arr);
            if(!set.contains(arr)) {
                list.add(arr[0]);
                num--;
            }
        }

        while (!stack.isEmpty())
            tem.add(stack.pop());
        return list;
    }

    public void rent(int shop, int movie) {
        int[]tem=shops[shop].get(movie);
        set.add(tem);
        jie.add(tem);
    }

    public void drop(int shop, int movie) {
        int[]tem=shops[shop].get(movie);
        set.remove(tem);
        jie.remove(tem);
    }

    public List&lt;List&lt;Integer&gt;&gt; report() {
        int num=5;
        PriorityQueue&lt;int[]&gt;tem=jie;
        List&lt;List&lt;Integer&gt;&gt;list=new ArrayList&lt;&gt;();
        Stack&lt;int[]&gt;stack=new Stack&lt;&gt;();
        while (!tem.isEmpty()&amp;&amp;num&gt;0)
        {
            int[]arr=tem.poll();
            stack.add(arr);
                List&lt;Integer&gt; ll = new ArrayList&lt;&gt;();
                ll.add(arr[0]);
                ll.add(arr[1]);
                list.add(ll);
                num--;
        }
        while (!stack.isEmpty())
            jie.add(stack.pop());
        return list;
    }
}
</code></pre>
<p>我们都知道Java有一个常量池，例如Integer整型常量池，有一个特殊的范围<code>-128 ~ 127</code>，当我们创建在范围内的Integer对象时，Java会自动将指针指向常量池已有对象，这时如果我们用<code>==</code>或者<code>!=</code>判断时是没有问题的，但是当我们创建的对象超出了范围，就会自行创建相应的新对象，该对象拥有不同的指针地址，即使他们的对象值相同，<code>==</code>运算时也不会相等，因为地址不同，不是同一个对象，必须使用<code>equals()</code>方法来解决问题<br>
这道题目中，<code>Map&lt;Integer, Integer&gt;</code>取出的<code>value</code>是Integer类型的，直接写入lambda表达式时应当注意，不能使用<code>==</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Thymeleaf模版布局和资源引入]]></title>
        <id>https://rayzhang13.github.io/post/thymeleaf-usages/</id>
        <link href="https://rayzhang13.github.io/post/thymeleaf-usages/">
        </link>
        <updated>2021-06-21T05:48:40.000Z</updated>
        <summary type="html"><![CDATA[<p>Thymeleaf是一种用于Web和独立环境的现代服务器端的Java模板引擎。<br>
Thymeleaf的主要目标是将优雅的自然模板带到开发工作流程中，并将HTML在浏览器中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。<br>
Thymeleaf使用Spring框架的模块，与许多常见的工具集成在一起，并且可以插入自己的功能，是现代HTML5 JVM Web开发的理想选择，尽管Thymeleaf还有更多其它的功能。Thymeleaf建立在自然模板的概念之上，以不影响模板作为设计原型的方式将其逻辑注入到模板文件中。 这改善了设计沟通，弥合了前端设计和开发人员之间的理解偏差。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Thymeleaf是一种用于Web和独立环境的现代服务器端的Java模板引擎。<br>
Thymeleaf的主要目标是将优雅的自然模板带到开发工作流程中，并将HTML在浏览器中正确显示，并且可以作为静态原型，让开发团队能更容易地协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。<br>
Thymeleaf使用Spring框架的模块，与许多常见的工具集成在一起，并且可以插入自己的功能，是现代HTML5 JVM Web开发的理想选择，尽管Thymeleaf还有更多其它的功能。Thymeleaf建立在自然模板的概念之上，以不影响模板作为设计原型的方式将其逻辑注入到模板文件中。 这改善了设计沟通，弥合了前端设计和开发人员之间的理解偏差。</p>
<!-- more -->
<h1 id="问题引入">问题引入</h1>
<p>当直接访问<code>HTML</code>文件时，可以访问到的部分静态资源可能由于路径配置的原因，在Springboot中报错，我们希望能在不影响当前网页功能、不破坏结构的情况下修改路径达到效果<br>
又或者在前端各页面中存在大量雷同的代码块，例如博客项目中存在Navigation Bar和footer等布局大量相同的情况，如果想对这些布局中等元素进行统一修改将会非常麻烦</p>
<p>而Thymeleaf很好的解决了这样的痛点</p>
<h1 id="项目示例">项目示例</h1>
<p>以下将做几个博客中简单的示例：<br>
我们定义一个Thymeleaf模版<code>_fragment.html</code></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head th:fragment=&quot;head(title)&quot;&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title th:replace=&quot;${title}&quot;&gt;博客详情&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/semantic-ui@2.2.4/dist/semantic.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/css/typo.css&quot; th:href=&quot;@{/css/typo.css}&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/css/me.css&quot; th:href=&quot;@{/css/me.css}&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/css/animate.css&quot; th:href=&quot;@{/css/animate.css}&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/lib/prism/prism.css&quot; th:href=&quot;@{/lib/prism/prism.css}&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/lib/tocbot/tocbot.css&quot; th:href=&quot;@{/lib/tocbot/tocbot.css}&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/lib/editormd/css/editormd.css&quot; th:href=&quot;@{/lib/editormd/css/editormd.css}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;nav th:fragment=&quot;menu(n)&quot; class=&quot;ui inverted attached segment m-padded-tb-mini m-shadow-small&quot;&gt;
  &lt;div class=&quot;ui container&quot;&gt;
    &lt;div class=&quot;ui inverted secondary stackable menu&quot;&gt;
      &lt;h2 class=&quot;ui teal header item&quot;&gt;Blog&lt;/h2&gt;
      &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot; th:classappend=&quot;${n==1}?'active'&quot;&gt;&lt;i class=&quot;home icon&quot;&gt;&lt;/i&gt;首页&lt;/a&gt;
      &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot; th:classappend=&quot;${n==2}?'active'&quot;&gt;&lt;i class=&quot;idea icon&quot;&gt;&lt;/i&gt;分类&lt;/a&gt;
      &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot; th:classappend=&quot;${n==3}?'active'&quot;&gt;&lt;i class=&quot;tags icon&quot;&gt;&lt;/i&gt;标签&lt;/a&gt;
      &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot; th:classappend=&quot;${n==4}?'active'&quot;&gt;&lt;i class=&quot;clone icon&quot;&gt;&lt;/i&gt;归档&lt;/a&gt;
      &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot; th:classappend=&quot;${n==5}?'active'&quot;&gt;&lt;i class=&quot;info icon&quot;&gt;&lt;/i&gt;关于我&lt;/a&gt;
      &lt;div class=&quot;right item m-mobile-hide&quot;&gt;
        &lt;div class=&quot;ui icon inverted transparent input&quot;&gt;
          &lt;input type=&quot;text&quot; placeholder=&quot;Search....&quot;&gt;
          &lt;i class=&quot;search link icon&quot;&gt;&lt;/i&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;a href=&quot;#&quot; class=&quot;ui menu toggle black icon button m-right-top m-mobile-show&quot;&gt;
    &lt;i class=&quot;sidebar icon&quot;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/nav&gt;

&lt;footer th:fragment=&quot;footer&quot; class=&quot;ui inverted vertical segment m-padded-tb-massive&quot;&gt;
......
&lt;/footer&gt;

&lt;th:block th:fragment=&quot;script&quot;&gt;
  &lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery.scrollto@2.1.3/jquery.scrollTo.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../static/lib/prism/prism.js&quot; th:src=&quot;@{/lib/prism/prism.js}&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../static/lib/tocbot/tocbot.min.js&quot; th:src=&quot;@{/lib/tocbot/tocbot.min.js}&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../static/lib/qrcode/qrcode.min.js&quot; th:src=&quot;@{/lib/qrcode/qrcode.min.js}&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../static/lib/waypoint/jquery.waypoints.min.js&quot; th:src=&quot;@{/lib/waypoint/jquery.waypoints.min.js}&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../../static/lib/editormd/editormd.js&quot; th:src=&quot;@{/lib/editormd/editormd.js}&quot;&gt;&lt;/script&gt;
&lt;/th:block&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>其中</p>
<ul>
<li>head块中，引入参数title，用于替换标签页标题“博客详情”字样</li>
<li>menu块中，引入参数n，不同的n对应不同的顶栏按钮被追加<code>active</code>属性</li>
<li>footer和script块也为类似模版代码</li>
<li>注意到src路径在Springboot中由于静态资源的路径问题，不生效，我们改由Thymeleaf使用<code>th:href</code>和<code>th:src</code>标签引入static下的新路径</li>
</ul>
<p>具体调用方法如下：<br>
在博客首页<code>index.html</code>中：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head th:replace=&quot;_fragments :: head(~{::title})&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/semantic-ui@2.2.4/dist/semantic.min.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/css/me.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;!--导航--&gt;
    &lt;nav th:replace=&quot;_fragments :: menu(1)&quot; class=&quot;ui inverted attached segment m-padded-tb-mini m-shadow-small&quot;&gt;
        &lt;div class=&quot;ui container&quot;&gt;
            &lt;div class=&quot;ui inverted secondary stackable menu&quot;&gt;
                &lt;h2 class=&quot;ui teal header item&quot;&gt;Blog&lt;/h2&gt;
                &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot;&gt;&lt;i class=&quot;home icon&quot;&gt;&lt;/i&gt;首页&lt;/a&gt;
                &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot;&gt;&lt;i class=&quot;idea icon&quot;&gt;&lt;/i&gt;分类&lt;/a&gt;
                &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot;&gt;&lt;i class=&quot;tags icon&quot;&gt;&lt;/i&gt;标签&lt;/a&gt;
                &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot;&gt;&lt;i class=&quot;clone icon&quot;&gt;&lt;/i&gt;归档&lt;/a&gt;
                &lt;a href=&quot;#&quot; class=&quot;m-item item m-mobile-hide&quot;&gt;&lt;i class=&quot;info icon&quot;&gt;&lt;/i&gt;关于我&lt;/a&gt;
                &lt;div class=&quot;right item m-mobile-hide&quot;&gt;
                    &lt;div class=&quot;ui icon inverted transparent input&quot;&gt;
                        &lt;input type=&quot;text&quot; placeholder=&quot;Search....&quot;&gt;
                        &lt;i class=&quot;search link icon&quot;&gt;&lt;/i&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;a href=&quot;#&quot; class=&quot;ui menu toggle black icon button m-right-top m-mobile-show&quot;&gt;
            &lt;i class=&quot;sidebar icon&quot;&gt;&lt;/i&gt;
        &lt;/a&gt;
    &lt;/nav&gt;
   &lt;!--底部footer--&gt;
    &lt;footer th:replace=&quot;_fragments :: footer&quot; class=&quot;ui inverted vertical segment m-padded-tb-massive&quot;&gt;
        ............
    &lt;/footer&gt;
    &lt;!--/*/&lt;th:block th:replace=&quot;_fragments :: script&quot;&gt;/*/--&gt;
        &lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js&quot;&gt;&lt;/script&gt;
    &lt;!--/*/&lt;/th:block&gt;/*/--&gt;

    &lt;script&gt;
        $('.menu.toggle').click(function (){
            $('.m-item').toggleClass('m-mobile-hide');
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>通过<code>th:replace=&quot;_fragments :: head(~{::title})&quot;</code>的方式，我们从原先<code>inedx</code>的代码块中获取到了<code>title</code>的值并将它覆盖到了<code>_fragments</code>对应模版上，随后使用模版替换了当前代码块</li>
<li>通过<code>th:replace=&quot;_fragments :: menu(1)&quot;</code> 加入了参数<code>n = 1</code>，触发了<code>_fragments</code>中对首页按钮追加的<code>active</code>属性，随后使用模版替换了代码块（甚至导航整块删除后Springboot访问仍然不受影响，因为已经被Thymeleaf替换了，但是本地静态网页渲染时结构会遭到破坏）</li>
<li>通过加入<code>&lt;!--/*/&lt;th:block th:replace=&quot;_fragments :: script&quot;&gt;/*/--&gt;</code> 和<code>&lt;!--/*/&lt;/th:block&gt;/*/--&gt;</code>注释的方式，我们可以让浏览器直接加载HTML时忽略外部的包裹，而实际Springboot启动时，Thymeleaf代码块会视其为有效</li>
</ul>
<p><font color="#FF0000"><b>PS：Thymeleaf的妙处就在这里，在本地打开对应的HTML时，Thymeleaf代码不生效，使用对应的本地路径，可以确保浏览器正常渲染，而使用Springboot时，Thymeleaf会注入模版和参数，按照我们之前配置的形式去运行，我们只需要对对应代码块加入一个标签就能实现托管</b></font></p>
<p>类似的我们还可以使用<code>th:inline</code>对Javascript和jQuery代码进行修改</p>
<p>例如，在博客输入页面中，我们引入了markdown-editor部件，并引入了css和js文件（已经通过Thymeleaf完成了路径替换）</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head th:replace=&quot;_fragments :: head(~{::title})&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;博客发布&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/semantic-ui@2.2.4/dist/semantic.min.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;../../static/lib/editormd/css/editormd.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;../../static/css/me.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    ..................
    &lt;!--/*/&lt;th:block th:replace=&quot;_fragments :: script&quot;&gt;/*/--&gt;
    &lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../../static/lib/editormd/editormd.js&quot;&gt;&lt;/script&gt;
    &lt;!--/*/&lt;/th:block&gt;/*/--&gt;
    .................
&lt;/body&gt;
</code></pre>
<p>关键在于为了markdown对正常使用，官方使用了一段jQuery代码：</p>
<pre><code class="language-html">&lt;script&gt;
        var contentEditor;
        $(function() {
            contentEditor = editormd(&quot;md-content&quot;, {
                width   : &quot;100%&quot;,
                height  : 640,
                syncScrolling : &quot;single&quot;,
                path    : &quot;../../static/lib/editormd/lib/&quot;,
                tex: true,
                flowChart : true,
                sequenceDiagram : true
            });
        });
&lt;/script&gt;
</code></pre>
<p>对应资源目录如下：<br>
<img src="https://rayzhang13.github.io/post-images/1624258956725.png" alt="" loading="lazy"><br>
本地环境下浏览器渲染运行无问题</p>
<p>而部署到Springboot上时，插件开始转圈，并且无法加载：<br>
<img src="https://rayzhang13.github.io/post-images/1624257326637.png" alt="" loading="lazy"><br>
显然由于路径配置问题，<code>&quot;../../static/lib/editormd/lib/&quot;</code>路径下的js和css文件不能生效，爆出404错误</p>
<p>这里我们采用<code>th:inline</code>对jQuery进行修改：</p>
<pre><code class="language-html">&lt;script th:inline=&quot;javascript&quot;&gt;
        var contentEditor;
        $(function() {
            contentEditor = editormd(&quot;md-content&quot;, {
                width   : &quot;100%&quot;,
                height  : 640,
                syncScrolling : &quot;single&quot;,
                path    : /*[[@{/lib/editormd/lib/}]]*/ &quot;../../static/lib/editormd/lib/&quot;,
                tex: true,
                flowChart : true,
                sequenceDiagram : true
            });
        });
&lt;/script&gt;
</code></pre>
<p>由于引入了注释，本地访问时浏览器仍然会去请求<code>&quot;../../static/lib/editormd/lib/&quot;</code>目录，而使用Springboot进行部署时，Thymeleaf会使用<code>@{/lib/editormd/lib/}</code>路径对原先路径进行替换</p>
<p>如图样式加载正常：<br>
<img src="https://rayzhang13.github.io/post-images/1624257617100.png" alt="" loading="lazy"><br>
达到了预期效果</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot下静态资源访问问题]]></title>
        <id>https://rayzhang13.github.io/post/springboot-static-resources-missing/</id>
        <link href="https://rayzhang13.github.io/post/springboot-static-resources-missing/">
        </link>
        <updated>2021-06-20T14:43:09.000Z</updated>
        <summary type="html"><![CDATA[<p>在我们开发Web应用的时候，会用到大量的js、css、image、html等静态资源资源。<br>
如果无法访问，会导致样式错乱和贴图缺失等问题，严重影响观感</p>
]]></summary>
        <content type="html"><![CDATA[<p>在我们开发Web应用的时候，会用到大量的js、css、image、html等静态资源资源。<br>
如果无法访问，会导致样式错乱和贴图缺失等问题，严重影响观感</p>
<!-- more -->
<h1 id="问题描述">问题描述</h1>
<p>resources文件目录如下：<br>
<img src="https://rayzhang13.github.io/post-images/1624200880721.png" alt="" loading="lazy"></p>
<p><code>index.html</code>头部大致如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/html&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/semantic-ui@2.2.4/dist/semantic.min.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/css/me.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<p>通过IDEA或finder打开对应网页<code>index.html</code>时，样式图片都齐全<br>
<img src="https://rayzhang13.github.io/post-images/1624200485646.png" alt="" loading="lazy"></p>
<p>当我们通过浏览器请求servlet加载<code>index.html</code>时，样式发生错乱<br>
<img src="https://rayzhang13.github.io/post-images/1624200606977.png" alt="" loading="lazy"></p>
<p>F12查看元素：<br>
<img src="https://rayzhang13.github.io/post-images/1624200662077.png" alt="" loading="lazy"><br>
css文件爆出404错误，说明对应的<code>me.css</code>文件无法被访问到</p>
<h1 id="静态资源映射">静态资源映射</h1>
<p>默认情况下，我们只需要将静态资源放在一下几个目录中就可以直接通过url在浏览器中访问了</p>
<ul>
<li><code>/META-INF/resources/</code></li>
<li><code>/resources/</code></li>
<li><code>/static/</code></li>
<li><code>/public/</code></li>
</ul>
<p>如果这四个目录中有相同的静态资源文件，那么优先访问哪个目录下面的资源啊？<br>
静态资源的默认访问优先级：<code>/META-INF/resources/</code>&gt;<code>/resources/</code>&gt;<code>/static/</code>&gt;<code>/public/</code></p>
<p>在上述问题中，css文件被放置到了<code>../static/css/</code>目录下，导致无法被访问</p>
<h1 id="解决方案1配置文件指定静态资源映射">解决方案1：配置文件指定静态资源映射</h1>
<p>在springboot配置文件<code>application.properties</code>中指定静态资源映射</p>
<pre><code class="language-xml">spring.mvc.static-path-pattern=/static/**
spring.resources.static-locations= classpath:static/
</code></pre>
<h1 id="解决方案2使用thymeleaf引用静态资源">解决方案2：使用Thymeleaf引用静态资源</h1>
<p>将<code>index.html</code>中加入Thymeleaf模块：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/semantic-ui@2.2.4/dist/semantic.min.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;../static/css/me.css&quot; th:href=&quot;@{/css/me.css}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
</code></pre>
<!-- more -->
<p><img src="https://rayzhang13.github.io/post-images/1624201441924.png" alt="" loading="lazy"><br>
可以看见，css已经正常加载</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用@ControllerAdvice与@ExceptionHandler拦截异常]]></title>
        <id>https://rayzhang13.github.io/post/exception-handler-interceptor/</id>
        <link href="https://rayzhang13.github.io/post/exception-handler-interceptor/">
        </link>
        <updated>2021-06-20T12:31:16.000Z</updated>
        <summary type="html"><![CDATA[<p>本文将结合项目简单介绍如何对Controller层异常进行拦截</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文将结合项目简单介绍如何对Controller层异常进行拦截</p>
<!-- more -->
<p>正常情况下，如果访问发生异常错误，Spring Boot自动配置的默认错误处理器会查找名为error的视图，如果找不到就用默认的白标错误视图，如下图所示。<br>
<img src="https://rayzhang13.github.io/post-images/1624192927051.webp" alt="" loading="lazy"></p>
<p>如果我们在<code>/templates/error</code>目录下预先放置了<code>404.html</code> <code>500.html</code>等错误静态页面，Springboot会自动进行对应跳转，显得十分便利。<br>
<img src="https://rayzhang13.github.io/post-images/1624194092842.png" alt="" loading="lazy"></p>
<p>而 为了自定义错误界面，我们可能需要对Controller类产生的异常进行拦截，在此我们使用到了两个注解：<code>@ControllerAdvice</code> <code>@ExceptionHandler</code></p>
<h1 id="controlleradvice注解"><code>@ControllerAdvice</code>注解</h1>
<p><code>@ControllerAdvice</code>是控制器增强注解。可以用于定义<code>@ExceptionHandler</code>、<code>@InitBinder</code>、<code>@ModelAttribute</code>，并应用到所有<code>@RequestMapping</code>中。<br>
启动应用后，被 <code>@ExceptionHandler</code>、<code>@InitBinder</code>、<code>@ModelAttribute</code> 注解的方法，都会作用在 被 <code>@RequestMapping</code> 注解的方法上。<br>
<code>@ExceptionHandler</code> 拦截了异常，我们可以通过该注解实现自定义异常处理。其中，<code>@ExceptionHandler</code> 配置的 value 指定需要拦截的异常类型，下面拦截了 Exception.class 这种异常。</p>
<h1 id="代码实例">代码实例</h1>
<h2 id="全局处理">全局处理</h2>
<p>Handler类：</p>
<pre><code class="language-java">package com.ray.blog.handler;

import lombok.extern.log4j.Log4j2;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.servlet.ModelAndView;
import javax.servlet.http.HttpServletRequest;
@ControllerAdvice
@Log4j2
public class ControllerExceptionHandler {
    @ExceptionHandler(Exception.class) //拦截所有Exception类
    public ModelAndView exceptionHandler(HttpServletRequest httpServletRequest, Exception e) throws Exception {
        log.error(&quot;find exception:e={}&quot;,e.getMessage());  //log4j2在日志中打印错误信息
        ModelAndView mv = new ModelAndView();
        //将访问信息和异常写入参数中
        mv.addObject(&quot;url&quot;, httpServletRequest.getRequestURL());
        mv.addObject(&quot;exception&quot;, e);
        //重定向到error/error中
        mv.setViewName(&quot;error/error&quot;);
        return mv;
    }
}
</code></pre>
<p>我们故意将Controller类中加入报错代码：</p>
<pre><code class="language-java">package com.ray.blog.web;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class IndexController {
    @GetMapping(&quot;/&quot;)
    public String index(){
        int a = 7/0; //报错代码
        return &quot;index&quot;;
    }
}
</code></pre>
<p>访问<code>127.0.0.1:8080</code>后，产生异常，随后被拦截重定向到error页面，达到了我们的预期效果<br>
为了调试方便，我们将<code>error.html</code>套用了Thymeleaf，以注释的方式将具体异常信息注入到网页中</p>
<p>页面如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;error&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;error&lt;/h1&gt;
    &lt;div th:utext=&quot;${exception.message}&quot;&gt;&lt;/div&gt;
    &lt;!--以注释的形式将异常相关内容打印在网页中--&gt;
    &lt;div&gt;
        &lt;div th:utext=&quot;'&amp;lt;!--'&quot; th:remove=&quot;tag&quot;&gt;&lt;/div&gt;
        &lt;div th:utext=&quot;'Failed Request URL: ' + ${url}&quot; th:remove=&quot;tag&quot;&gt;&lt;/div&gt;
        &lt;div th:utext=&quot;'ExceptionMessage: ' + ${exception.message}&quot; th:remove=&quot;tag&quot;&gt;&lt;/div&gt;
        &lt;ul th:remove=&quot;tag&quot;&gt;
            &lt;li th:each=&quot;st : ${exception.stackTrace}&quot; th:remove=&quot;tag&quot;&gt;
                &lt;span th:utext=&quot;${st}&quot; th:remove=&quot;tag&quot;&gt;&lt;/span&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
        &lt;div th:utext=&quot;'--&amp;gt;'&quot; th:remove=&quot;tag&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>效果如下：</p>
<p>日志信息：</p>
<pre><code class="language-bash">21:07:40.673 [http-nio-8080-exec-8] ERROR com.ray.blog.handler.ControllerExceptionHandler 
- find exception:e=/ by zero
21:07:40.673 [http-nio-8080-exec-8] WARN  org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver 
- Resolved [java.lang.ArithmeticException: / by zero]
</code></pre>
<p>页面：<br>
<img src="https://rayzhang13.github.io/post-images/1624194537908.png" alt="" loading="lazy"></p>
<p>具体异常信息以注释方式被注入：<br>
<img src="https://rayzhang13.github.io/post-images/1624194590134.png" alt="" loading="lazy"></p>
<p>显然通过<code>@ExceptionHandler</code>的多重组合，我们可以应用于不同异常的拦截，分别设置重定向的页面</p>
<h2 id="使用注解处理自定义异常">使用注解处理自定义异常</h2>
<p>假设我们自定义异常NotFound：</p>
<pre><code class="language-java">package com.ray.blog;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
//使用RsponseStatus注解标注
public class NotFoundException extends RuntimeException {
    public NotFoundException(){
    }
    public NotFoundException(String message){
        super(message);
    }
    public NotFoundException(String message, Throwable cause){
        super(message, cause);
    }
}
</code></pre>
<p>Controller类中特意加入：</p>
<pre><code class="language-java">package com.ray.blog.web;
import com.ray.blog.NotFoundException;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
@Controller
public class IndexController {
    @GetMapping(&quot;/&quot;)
    public String index(){
        String blog = null;
        if(blog == null){
            throw new NotFoundException(&quot;博客不存在&quot;);
        }
        return &quot;index&quot;;
    }
}
</code></pre>
<p>我们在Handler类中加入额外两行：</p>
<pre><code class="language-java">package com.ray.blog.handler;

import lombok.extern.log4j.Log4j2;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.servlet.ModelAndView;
import javax.servlet.http.HttpServletRequest;


@ControllerAdvice
@Log4j2
public class ControllerExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ModelAndView exceptionHandler(HttpServletRequest httpServletRequest, Exception e) throws Exception {
        log.error(&quot;find exception:e={}&quot;,e.getMessage());
        if(AnnotationUtils.findAnnotation(e.getClass(), ResponseStatus.class) != null){
            //若异常对应注解包含ResponseStatus，直接将异常抛出
            throw e;
        }
        //否则跳转到error.html
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;url&quot;, httpServletRequest.getRequestURL());
        mv.addObject(&quot;exception&quot;, e);
        mv.setViewName(&quot;error/error&quot;);
        return mv;
    }
}
</code></pre>
<p>随后我们对<code>127.0.0.1:8080</code>进行访问，会抛出我们自定义的异常，并由Springboot直接跳转到静态的404页面。<br>
<img src="https://rayzhang13.github.io/post-images/1624195254082.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AOP 切面统一打印请求日志（博客项目）]]></title>
        <id>https://rayzhang13.github.io/post/request-aop-log/</id>
        <link href="https://rayzhang13.github.io/post/request-aop-log/">
        </link>
        <updated>2021-06-20T12:04:12.000Z</updated>
        <summary type="html"><![CDATA[<p>在请求servlet的过程中，我们可以使用AOP给我们的项目添加日志打印功能<br>
本文中，我们将详细描述如何使用AOP，将HttpRequest相关信息记录在日志中</p>
]]></summary>
        <content type="html"><![CDATA[<p>在请求servlet的过程中，我们可以使用AOP给我们的项目添加日志打印功能<br>
本文中，我们将详细描述如何使用AOP，将HttpRequest相关信息记录在日志中</p>
<!-- more -->
<h1 id="预期效果">预期效果</h1>
<p>之前尝试调试成功的 若依 项目，在访问index页面并登陆成功后，后台日志会有如下显示：<br>
<img src="https://rayzhang13.github.io/post-images/1624191171817.png" alt="" loading="lazy"><br>
这是通过AOP切面的形式添加的功能</p>
<p>我们目标将如下参数打印在日志中：</p>
<ul>
<li>URL: 请求接口地址；</li>
<li>HTTP Method: 请求的方法，是 POST, GET, 还是 DELETE 等；</li>
<li>Class Method: 对应 Controller 的全路径以及调用的哪个方法;</li>
<li>IP: 请求 IP 地址；</li>
<li>Request Args: 请求入参，以 JSON 格式输出；</li>
</ul>
<h1 id="上手实现">上手实现</h1>
<p>在此我们使用了Log4j2作为日志工具，配合Lombok插件</p>
<p>配置AOP切面 和 日志封装类：</p>
<pre><code class="language-java">package com.ray.blog.aspect;

import lombok.AllArgsConstructor;
import lombok.ToString;
import lombok.extern.log4j.Log4j2;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;

@Aspect
@Component
@Log4j2
public class LogAspect {
    @Pointcut(&quot;execution(* com.ray.blog.web.*.*(..))&quot;)
    public void log(){}

    @Before(&quot;log()&quot;)
    public void doBefore(JoinPoint joinPoint){
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        //根据HttpServletRequest对象，获得相应参数
        String url = request.getRequestURL().toString();
        String ip = request.getRemoteAddr();
        String classMethod = joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        //封装成类
        RequestLog requestLog = new RequestLog(url, ip, classMethod, args);
        //日志打印
        log.info(&quot;Request: {}&quot;, requestLog);
//        log.info(&quot;-----------doBefore-------------&quot;);
    }
    @After(&quot;log()&quot;)
    public void doAfter(){
//        log.info(&quot;-------------doAfter-----------------&quot;);
    }
    @AfterReturning(returning = &quot;result&quot;, pointcut = &quot;log()&quot;)
    public void doAfterReturn(Object result){
//        log.info(&quot;Result: {}&quot;, result);
    }

    @AllArgsConstructor
    @ToString       //调用了有参构造和toString()方法
    private class RequestLog{
        private String url;
        private String ip;
        private String classMethod;
        private Object[] args;
    }
}
</code></pre>
<p>配置Servlet Controller:</p>
<pre><code class="language-java">package com.ray.blog.web;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@Controller
public class IndexController {
    @GetMapping(&quot;/{a}/{b}&quot;)
    public String index(@PathVariable String a, @PathVariable String b){
        return &quot;index&quot;;
    }
}
</code></pre>
<p>例如当我访问<code>127.0.0.1:8080/ray/123456</code>时<br>
面板会产生如下日志，表示AOP已经正常运行</p>
<pre><code class="language-bash">20:18:39.973 [http-nio-8080-exec-4] INFO  com.ray.blog.aspect.LogAspect - Request: 
LogAspect.RequestLog(url=http://127.0.0.1:8080/ray/123456, ip=127.0.0.1, classMethod=com.ray.blog.web.IndexController.index, args=[ray, 123456])
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring 学习笔记（持续更新）]]></title>
        <id>https://rayzhang13.github.io/post/spring-notes/</id>
        <link href="https://rayzhang13.github.io/post/spring-notes/">
        </link>
        <updated>2021-06-20T12:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>Spring之前学的太仓促了，现在来总结一下<br>
<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/index.html">Spring Framework Documentation</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Spring之前学的太仓促了，现在来总结一下<br>
<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/index.html">Spring Framework Documentation</a></p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://rayzhang13.github.io/post-images/1622794061089.png" alt="" loading="lazy"></figure>
<h1 id="简介">简介</h1>
<p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。<br>
<strong>简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</strong></p>
<h1 id="spring-ioc">Spring IoC</h1>
<h2 id="quick-start">Quick Start</h2>
<ol>
<li>Maven pom.xml依赖配置如下</li>
</ol>
<pre><code class="language-xml">&lt;packaging&gt;jar&lt;/packaging&gt;
&lt;dependencies&gt;
        &lt;!--导入Spring相关jar包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.2.12.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--导入测试相关jar包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
&lt;/dependencies&gt; 
</code></pre>
<ol start="2">
<li>创建实体类</li>
</ol>
<pre><code class="language-java">package com.ray.pojo;

public class User {
    String name;
    Integer id;
    public User(String name, Integer id) {
        System.out.println(&quot;调用有参构造&quot;);
        this.name = name;
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setId(Integer id) {
        System.out.println(&quot;调用setId&quot;);
        this.id = id;
    }
    public void setName(String name) {
        System.out.println(&quot;调用setName&quot;);
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, id=&quot; + id +
                '}';
    }
    public Integer getId() {
        return id;
    }
    public User() {
        System.out.println(&quot;调用无参构造&quot;);
    }
}

</code></pre>
<ol start="3">
<li>Resource目录下创建配置文件 bean.xml</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;User&quot; class=&quot;com.ray.pojo.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Ray&quot;/&gt;
        &lt;property name=&quot;id&quot; value=&quot;123&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>需要注意的是property设置时对应类中的Setter方法，若无对应Setter方法则会发生报错</p>
<ol start="4">
<li>测试类调用</li>
</ol>
<pre><code class="language-java">import com.ray.pojo.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
        //User user = (User)applicationContext.getBean(&quot;user&quot;);
        User user = applicationContext.getBean(&quot;User&quot;, User.class);
        System.out.println(user);
    }
}
</code></pre>
<p>结果：</p>
<pre><code class="language-bash">/Users/ray/Library/Java/JavaVirtualMachines/openjdk-15.0.2/Contents/Home/bin/java -javaagent:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=58760:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/ray/Downloads/Spring/target/test-classes:/Users/ray/Downloads/Spring/target/classes:/Users/ray/.m2/repository/org/springframework/spring-context/5.2.12.RELEASE/spring-context-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-aop/5.2.12.RELEASE/spring-aop-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-beans/5.2.12.RELEASE/spring-beans-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-core/5.2.12.RELEASE/spring-core-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-jcl/5.2.12.RELEASE/spring-jcl-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-expression/5.2.12.RELEASE/spring-expression-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/junit/junit/4.12/junit-4.12.jar:/Users/ray/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar Test
调用无参构造
调用setName
调用setId
User{name='Ray', id=123}

Process finished with exit code 0
</code></pre>
<h2 id="ioc获取bean方式">IoC获取bean方式</h2>
<ol>
<li>根据 id 获取<br>
根据bean.xml中配置的bean的唯一标识id进行查找</li>
</ol>
<pre><code class="language-java">User user = (User)applicationContext.getBean(&quot;user&quot;)
</code></pre>
<ol start="2">
<li>通过 bean 类型获取<br>
如果同一个类型的bean在xml文件中配置了多个，则获取时会抛出异常，所以<strong>同一个类型的bean在容器中必须是唯一的</strong></li>
</ol>
<pre><code class="language-java">User user = applicationContext.getBean(User.class);
</code></pre>
<ol start="3">
<li>指定bean的 id 值和类型</li>
</ol>
<pre><code class="language-java">User user = applicationContext.getBean(&quot;User&quot;, User.class);
</code></pre>
<h2 id="beanfactory和applicationcontext区别">BeanFactory和ApplicationContext区别</h2>
<ul>
<li>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口, 包含 BeanFactory 的所有特性,它的主要功能是支持大型的业务应用的创建。</li>
<li>BeanFactroy采用的是<font color=#DC143C><b>延迟加载形式来注入Bean</b></font>的，<font color=#DC143C><b>即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化</b></font>。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</li>
<li>ApplicationContext，它是<font color=#DC143C><b>在容器启动时，一次性创建了所有的Bean</b></font>。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化；（饿汉式加载？）</li>
<li>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</li>
<li>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</li>
<li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor（后置处理器）的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li>
</ul>
<h2 id="ioc创建对象方式">IoC创建对象方式</h2>
<ol>
<li>
<p>默认使用无参构造，然后根据bean中设置的property属性调用对应的Setter方法。<font color=#DC143C>亦可通过p命名空间实现</font></p>
</li>
<li>
<p>可以采用constructor-arg进行下标赋值<font color=#DC143C>亦可通过c命名空间实现</font></p>
<ul>
<li>下标赋值</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;User&quot; class=&quot;com.ray.pojo.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;Ray&quot;/&gt;
        &lt;constructor-arg index=&quot;1&quot; value=&quot;123&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>运行结果：</p>
<pre><code class="language-bash">/Users/ray/Library/Java/JavaVirtualMachines/openjdk-15.0.2/Contents/Home/bin/java -javaagent:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=61025:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/ray/Downloads/Spring/target/test-classes:/Users/ray/Downloads/Spring/target/classes:/Users/ray/.m2/repository/org/springframework/spring-context/5.2.12.RELEASE/spring-context-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-aop/5.2.12.RELEASE/spring-aop-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-beans/5.2.12.RELEASE/spring-beans-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-core/5.2.12.RELEASE/spring-core-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-jcl/5.2.12.RELEASE/spring-jcl-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-expression/5.2.12.RELEASE/spring-expression-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/junit/junit/4.12/junit-4.12.jar:/Users/ray/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar Test
调用有参构造
User{name='Ray', id=123}

Process finished with exit code 0
</code></pre>
<ul>
<li>类型赋值<br>
根据args类型进行赋值（不建议使用）</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;User&quot; class=&quot;com.ray.pojo.User&quot;&gt;
        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;Ray&quot;/&gt;
        &lt;constructor-arg type=&quot;java.lang.Integer&quot; value=&quot;123&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">/Users/ray/Library/Java/JavaVirtualMachines/openjdk-15.0.2/Contents/Home/bin/java -javaagent:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=51746:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/ray/Downloads/Spring/target/test-classes:/Users/ray/Downloads/Spring/target/classes:/Users/ray/.m2/repository/org/springframework/spring-context/5.2.12.RELEASE/spring-context-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-aop/5.2.12.RELEASE/spring-aop-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-beans/5.2.12.RELEASE/spring-beans-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-core/5.2.12.RELEASE/spring-core-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-jcl/5.2.12.RELEASE/spring-jcl-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-expression/5.2.12.RELEASE/spring-expression-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/junit/junit/4.12/junit-4.12.jar:/Users/ray/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar Test
调用有参构造
User{name='Ray', id=123}

Process finished with exit code 0
</code></pre>
<ul>
<li>参数名赋值</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;User&quot; class=&quot;com.ray.pojo.User&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;Ray&quot;/&gt;
        &lt;constructor-arg name=&quot;id&quot; value=&quot;123&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>运行结果：</p>
<pre><code class="language-bash">/Users/ray/Library/Java/JavaVirtualMachines/openjdk-15.0.2/Contents/Home/bin/java -javaagent:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=53590:/Users/ray/Library/Application Support/JetBrains/Toolbox/apps/IDEA-U/ch-0/211.7142.45/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/ray/Downloads/Spring/target/test-classes:/Users/ray/Downloads/Spring/target/classes:/Users/ray/.m2/repository/org/springframework/spring-context/5.2.12.RELEASE/spring-context-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-aop/5.2.12.RELEASE/spring-aop-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-beans/5.2.12.RELEASE/spring-beans-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-core/5.2.12.RELEASE/spring-core-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-jcl/5.2.12.RELEASE/spring-jcl-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/org/springframework/spring-expression/5.2.12.RELEASE/spring-expression-5.2.12.RELEASE.jar:/Users/ray/.m2/repository/junit/junit/4.12/junit-4.12.jar:/Users/ray/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar Test
调用有参构造
User{name='Ray', id=123}

Process finished with exit code 0
</code></pre>
</li>
</ol>
<h2 id="bean的作用域">Bean的作用域</h2>
<ol>
<li>singleton<br>
在SpringIOC容器中仅存在唯一一个Bean实例，Bean以单实例的方式存在</li>
<li>prototype<br>
每次调用getBean（）是都会返回一个新的实例</li>
<li>request（创建一个新的bean）<br>
每次HTTP请求都会创建一个新的Bean，作用域仅适用于WebApplicationContext环境</li>
<li>session（一个会话中共享bean）<br>
同一个HTTP Session 共享一个Bean，不同的HTTP Session 使用不同的Bean。该作用域适用于WebApplicationContext环境<br>
示例：</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;User&quot; class=&quot;com.ray.pojo.User&quot; scope=&quot;singleton&quot;&gt;
</code></pre>
<h2 id="bean的生命周期">Bean的生命周期</h2>
<h3 id="四个阶段">四个阶段</h3>
<ol>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ol>
<pre><code class="language-java">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
        BeanWrapper instanceWrapper = null;
        if (mbd.isSingleton()) {
            instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
        }

        if (instanceWrapper == null) {
            instanceWrapper = this.createBeanInstance(beanName, mbd, args);
        }

        Object bean = instanceWrapper.getWrappedInstance();
        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class) {
            mbd.resolvedTargetType = beanType;
        }

        synchronized(mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {
                    this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                } catch (Throwable var17) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, var17);
                }

                mbd.postProcessed = true;
            }
        }

        boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName);
        if (earlySingletonExposure) {
            if (this.logger.isTraceEnabled()) {
                this.logger.trace(&quot;Eagerly caching bean '&quot; + beanName + &quot;' to allow for resolving potential circular references&quot;);
            }

            this.addSingletonFactory(beanName, () -&gt; {
                return this.getEarlyBeanReference(beanName, mbd, bean);
            });
        }

        Object exposedObject = bean;

        try {
            this.populateBean(beanName, mbd, instanceWrapper);
            exposedObject = this.initializeBean(beanName, exposedObject, mbd);
        } catch (Throwable var18) {
            if (var18 instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) {
                throw (BeanCreationException)var18;
            }

            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, var18);
        }

        if (earlySingletonExposure) {
            Object earlySingletonReference = this.getSingleton(beanName, false);
            if (earlySingletonReference != null) {
                if (exposedObject == bean) {
                    exposedObject = earlySingletonReference;
                } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) {
                    String[] dependentBeans = this.getDependentBeans(beanName);
                    Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length);
                    String[] var12 = dependentBeans;
                    int var13 = dependentBeans.length;

                    for(int var14 = 0; var14 &lt; var13; ++var14) {
                        String dependentBean = var12[var14];
                        if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                            actualDependentBeans.add(dependentBean);
                        }
                    }

                    if (!actualDependentBeans.isEmpty()) {
                        throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.&quot;);
                    }
                }
            }
        }

        try {
            this.registerDisposableBeanIfNecessary(beanName, bean, mbd);
            return exposedObject;
        } catch (BeanDefinitionValidationException var16) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, var16);
        }
    }
</code></pre>
<p>doCreateBean()方法中调用了以下三个方法</p>
<ul>
<li>createBeanInstance() -&gt; 实例化</li>
<li>populateBean() -&gt; 属性赋值</li>
<li>initializeBean() -&gt; 初始化</li>
</ul>
<p>销毁是在ConfigurableApplicationContext#close()中使用的，是在容器关闭时调用的</p>
<h3 id="拓展点">拓展点</h3>
<p><img src="https://rayzhang13.github.io/post-images/1622680458805.webp" alt="" loading="lazy"><br>
后置处理器：InstantiationAwareBeanPostProcessor作用于实例化阶段的前后，BeanPostProcessor作用于初始化阶段的前后。正好和第一、第三个生命周期阶段对应。</p>
<p>InstantiationAwareBeanPostProcessor实际上继承了BeanPostProcessor接口，严格意义上来看他们不是两兄弟，而是两父子。但是从生命周期角度我们重点关注其特有的对实例化阶段的影响</p>
<h2 id="bean自动装配">Bean自动装配</h2>
<h3 id="装配模式介绍">装配模式介绍</h3>
<p>Spring 容器可以在不使用<constructor-arg>和<property> 元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。</p>
<pre><code class="language-java">public interface AutowireCapableBeanFactory{
	//无需自动装配
	int AUTOWIRE_NO = 0;
	//按名称自动装配bean属性
	int AUTOWIRE_BY_NAME = 1;
	//按类型自动装配bean属性
	int AUTOWIRE_BY_TYPE = 2;
	//按构造器自动装配
	int AUTOWIRE_CONSTRUCTOR = 3;
	//过时方法，Spring3.0之后不再支持
	@Deprecated
	int AUTOWIRE_AUTODETECT = 4;
}
</code></pre>
<p>下列自动装配模式，它们可用于指示 Spring 容器为来使用自动装配进行依赖注入。你可以使用<bean>元素的 autowire 属性为一个 bean 定义指定自动装配模式。</p>
<ol>
<li>no	这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。</li>
<li>byName	由属性名自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的 beans 的属性进行连接。</li>
<li>byType	由属性数据类型自动装配。Spring 容器看到在 XML 配置文件中 bean 的自动装配的属性设置为 byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。<font color=#DC143C>如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。</font></li>
<li>constructor	类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。</li>
<li><font color=#00FF00>autodetect（3.0版本不支持deprecated）</font>Spring首先尝试通过 constructor 使用自动装配来连接，如果它不执行，Spring 尝试通过 byType 来自动装配。</li>
</ol>
<h3 id="示例">示例</h3>
<h4 id="byname">byName</h4>
<pre><code class="language-java">package com.ray.pojo;
public class Role {
    public User user;
    public void setUser(User user) {
        this.user = user;
    }
}
</code></pre>
<pre><code class="language-java">package com.ray.pojo;
public class Role {
    public User user;
    public void setUser(User user) {
        this.user = user;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.ray.pojo.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Ray&quot;/&gt;
        &lt;property name=&quot;id&quot; value=&quot;123&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;role&quot; class=&quot;com.ray.pojo.Role&quot; autowire=&quot;byName&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>结果：</p>
<pre><code class="language-bash">调用无参构造
调用setName
调用setId
User{name='Ray', id=123}

Process finished with exit code 0
</code></pre>
<p>值得注意的是自动装配使用byName时，其id值为<code>&quot;user&quot;</code>与<code>Role</code>中的属性名称<code>&quot;user&quot;</code>相对应，若不对应则无法将对应参数进行填充。参数填充时需要与setter方法配合。</p>
<h4 id="bytype">byType</h4>
<p>类似的：</p>
<pre><code class="language-java">package com.ray.pojo;
public class Role {
    public User user;
    public void setUser(User user) {
        this.user = user;
    }
}
</code></pre>
<pre><code class="language-java">package com.ray.pojo;
public class Role {
    public User user;
    public void setUser(User user) {
        this.user = user;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.ray.pojo.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Ray&quot;/&gt;
        &lt;property name=&quot;id&quot; value=&quot;123&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;role&quot; class=&quot;com.ray.pojo.Role&quot; autowire=&quot;byType&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>结果：</p>
<pre><code class="language-bash">调用无参构造
调用setName
调用setId
User{name='Ray', id=123}

Process finished with exit code 0
</code></pre>
<p>如果bean的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。例如通过<code>Roles</code>类中的<code>com.ray.pojo.User</code>匹配到bean.xml中的<code>user</code> bean。参数填充时需要与setter方法配合。</p>
<h4 id="constructor">constructor</h4>
<pre><code class="language-java">package com.ray.pojo;
public class Role {
    public User user;
    public void setUser(User user) {
        this.user = user;
    }
    public Role() {
    }
    public Role(User user) {
        this.user = user;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.ray.pojo.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Ray&quot;/&gt;
        &lt;property name=&quot;id&quot; value=&quot;123&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;role&quot; class=&quot;com.ray.pojo.Role&quot; autowire=&quot;constructor&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>类似byType，按照类型进行匹配，但是不完全一样<br>
填充属性时，调用构造contructor方法，因此bean.xml中必须有与constructor方法参数中对应的已注册的bean，否则会发生错误</p>
<h4 id="default-autowire">default-autowire</h4>
<p>默认情况下，default-autowire属性被设置为none，标示所有的Bean都不使用自动装配，除非Bean上配置了autowire属性。 如果你需要为所有的Bean配置相同的autowire属性，有个办法可以简化这一操作。<br>
在配置文件中加入<code>&lt;beans default-autowire=&quot;byType&quot;&gt;</code></p>
<h2 id="自动装配中的循环依赖">自动装配中的循环依赖</h2>
<p>依赖注入稍不注意就会出现循环依赖：<br>
Bean之间的依赖顺序： BeanA -&gt; BeanB -&gt; BeanA<br>
即BeanA对象中引用了BeanB对象，而BeanB对象中又引用了BeanA</p>
<p><font color=#DC143C><b>解决方法：递归，三级缓存</b></font><br>
类似于执行图的深拷贝等类似的过程，无向图中我们使用<code>Map&lt;Node, Node&gt;</code>的方式，在遍历未完成节点的同时将已经完成拷贝的节点用Map的形式标记出来，下次再连接时直接从Map中取即可（可以认为是一级缓存？）</p>
<p>下面是未解决循环依赖的常规步骤：</p>
<ul>
<li>实例化 A，此时 A 还未完成属性填充和初始化方法（@PostConstruct）的执行。</li>
<li>A 对象发现需要注入 B 对象，但是容器中并没有 B 对象（如果对象创建完成并且属性注入完成和执行完初始化方法就会放入容器中）。</li>
<li>实例化 B，此时 B 还未完成属性填充和初始化方法（@PostConstruct）的执行。</li>
<li>B 对象发现需要注入 A 对象，但是容器中并没有 A 对象。</li>
<li>重复步骤 1。</li>
</ul>
<p>我们很容易的能够看出常规的解决循环依赖的步骤在这里并不起作用</p>
<p>从而引入<strong>三级缓存</strong>的概念</p>
<h3 id="三级缓存">三级缓存</h3>
<p>Spring解决循环依赖的核心思想在于<strong>提前曝光</strong></p>
<pre><code class="language-java">/** Cache of singleton objects: bean name to bean instance. */
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);
/** Cache of early singleton objects: bean name to bean instance. */
private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);
/** Cache of singleton factories: bean name to ObjectFactory. */
private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);
/** Names of beans that are currently in creation. */
// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~
// 它在Bean开始创建时放值，创建完成时会将其移出~
private final Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));
/** Names of beans that have already been created at least once. */
// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复
// 至少被创建了一次的  都会放进这里~~~~
private final Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256));
</code></pre>
<p>以下为三级缓存的对应作用</p>
<ul>
<li>singletonObjects 一级缓存，存放完整的 Bean。</li>
<li>earlySingletonObjects 二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法。<strong>用以解决循环依赖。</strong></li>
<li>singletonFactories 三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。<strong>用以解决循环依赖。</strong></li>
</ul>
<p>获取单例Bean的源码如下：</p>
<pre><code class="language-java">public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {
	...
	@Override
	@Nullable
	public Object getSingleton(String beanName) {
		return getSingleton(beanName, true);
	}
	@Nullable
	protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		Object singletonObject = this.singletonObjects.get(beanName);
		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
			synchronized (this.singletonObjects) {
				singletonObject = this.earlySingletonObjects.get(beanName);
				if (singletonObject == null &amp;&amp; allowEarlyReference) {
					ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
					if (singletonFactory != null) {
						singletonObject = singletonFactory.getObject();
						this.earlySingletonObjects.put(beanName, singletonObject);
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}
	...
	public boolean isSingletonCurrentlyInCreation(String beanName) {
		return this.singletonsCurrentlyInCreation.contains(beanName);
	}
	protected boolean isActuallyInCreation(String beanName) {
		return isSingletonCurrentlyInCreation(beanName);
	}
	...
}
</code></pre>
<ul>
<li>A半成品加入第三级缓存</li>
<li>A填充属性注入B -&gt; 创建B对象 -&gt; B半成品加入第三级缓存</li>
<li>B填充属性注入A -&gt; 创建A代理对象，从第三级缓存移除A对象，A代理对象加入第二级缓存（此时A还是半成品，B注入的是A代理对象）</li>
<li>创建B代理对象（此时B是完成品） -&gt; 从第三级缓存移除B对象，B代理对象加入第一级缓存</li>
<li>A半成品注入B代理对象</li>
<li>从第二级缓存移除A代理对象，A代理对象加入第一级缓存</li>
</ul>
<p><font color=#DC143C><b>PS: 加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</b></font></p>
<p>附上一张偷来的图：<br>
<img src="https://rayzhang13.github.io/post-images/1622815064103.png" alt="" loading="lazy"></p>
<h3 id="是否可以去掉第二级缓存">是否可以去掉第二级缓存？</h3>
<p><font color=#DC143C><b>关键在于AOP</b></font><br>
现在有A的field或者setter依赖B的实例对象，同时B的field或者setter依赖了A的实例，A首先开始创建，并将自己暴露到 earlySingletonObjects 中，开始填充属性，此时发现自己依赖B的属性，尝试去get(B)，发现B还没有被创建，所以开始创建B，在进行属性填充时初始化A，就从earlySingletonObjects 中获取到了实例化但没有任何属性的A，B拿到A后完成了初始化阶段，将自己放到singletonObjects中,此时返回A，A拿到B的对象继续完成初始化，完成后将自己放到singletonObjects中，由A与B中所表示的A的属性地址是一样的，所以A的属性填充完后，B也获取了A的属性，这样就解决了循环的问题。<br>
似乎完美解决，如果就这么使用的话也没什么问题，但是再加上AOP情况就不同了，被AOP增强的Bean会在初始化后代理成为一个新的对象，也就是说：如果有AOP，A依赖于B，B依赖于A，A实例化完成暴露出去，开始注入属性，发现引用B，B开始实例化，使用A暴露的对象，<strong>初始化完成后封装成代理对象</strong>，A再将代理后的B注入，再做代理，那么<strong>代理A中的B就是代理后的B，但是代理后的B中的A是没用代理的A</strong>。<br>
显然这是不对的，所以在Spring中存在第三级缓存，在创建对象时判断是否是单例，允许循环依赖，正在创建中，就将其从earlySingletonObjects中移除掉，并在singletonFactories放入新的对象，这样后续再查询beanName时会走到singletonFactory.getObject()，其中就会去调用各个beanPostProcessor的getEarlyBeanReference方法，返回的对象就是代理后的对象。</p>
<h3 id="是否可以去掉第三级缓存">是否可以去掉第三级缓存？</h3>
<p>是否可以：不管有没有循环依赖，都提前创建好代理对象，并将代理对象放入缓存，出现循环依赖时，其他对象直接就可以取到代理对象并注入。<br>
每次实例化完 Bean 之后就直接去创建代理对象，并添加到二级缓存中。测试结果是完全正常的，Spring 的初始化时间应该也是不会有太大的影响，因为如果 Bean 本身不需要代理的话，是直接返回原始 Bean 的，并不需要走复杂的创建代理 Bean 的流程。<br>
如果要使用二级缓存解决循环依赖，意味着Bean在构造完后就创建代理对象，这样违背了Spring设计原则。Spring结合AOP跟Bean的生命周期，是在Bean创建完全之后通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来完成的，在这个后置处理的postProcessAfterInitialization方法中对初始化后的Bean完成AOP代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。</p>
<h2 id="常用注解">常用注解</h2>
<h3 id="configuration注解">@Configuration注解</h3>
<p>该类等价 与XML中配置beans，相当于Ioc容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean，与xml中配置的bean意思一样。</p>
<p>@Configuration注解的类必需使用扫描.<br>
定义一个MainConfig，用@Configuration注解，那MainConfig相当于xml里的beans,里面用@Bean注解的和xml里定义的bean等价，用扫描该类，最终我们可以在程序里用@AutoWired或@Resource注解取得用@Bean注解的bean，和用xml先配置bean然后在程序里自动注入一样。目的是减少xml里配置。</p>
<h3 id="vaue注解">@Vaue注解</h3>
<p>为了简化从properties里取配置，可以使用@Value, 可以在properties文件中的配置值。</p>
<p>在dispatcher-servlet.xml里引入properties文件。<br>
<code>&lt;context:property-placeholder location=&quot;classpath:test.properties&quot; /&gt;</code><br>
在程序里使用@Value:</p>
<pre><code class="language-java">@Value(&quot;${wx_appid}&quot;)
public String appid;
</code></pre>
<p>即使给变量赋了初值也会以配置文件的值为准。</p>
<h3 id="controllerservicerepositorycomponent">@Controller,@Service,@Repository,@Component</h3>
<p>目前4种注解意思是一样，并没有什么区别，区别只是名字不同。</p>
<h3 id="postconstruct-和-predestory">@PostConstruct 和 @PreDestory</h3>
<p>实现初始化和销毁bean之前进行的操作，只能有一个方法可以用此注释进行注释，方法不能有参数，返回值必需是void,方法需要是非静态的。</p>
<pre><code class="language-java">public class TestService {
@PostConstruct  
public void  init(){  
    System.out.println(&quot;初始化&quot;);  
}

@PreDestroy  
public void  dostory(){  
    System.out.println(&quot;销毁&quot;);  
}  
}
</code></pre>
<h3 id="primary">@Primary</h3>
<p>自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常。</p>
<h3 id="lazytrue">@Lazy(true)</h3>
<p>用于指定该Bean是否取消预初始化，用于注解类，延迟初始化。</p>
<h3 id="autowired">@Autowired</h3>
<p>Autowired默认先按byType，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常。<br>
1.可以手动指定按byName方式注入，使用@Qualifier。<br>
//通过此注解完成从spring配置文件中 查找满足Fruit的bean,然后按//@Qualifier指定pean</p>
<pre><code class="language-java">@Autowired
@Qualifier(&quot;pean&quot;)
public Fruit fruit;
</code></pre>
<p>2.如果要允许null 值，可以设置它的required属性为false，如：</p>
<pre><code class="language-java">@Autowired(required=false)
public Fruit fruit;
</code></pre>
<h3 id="resource">@Resource</h3>
<p>默认按 byName自动注入,如果找不到再按byType找bean,如果还是找不到则抛异常，无论按byName还是byType如果找到多个，则抛异常。<br>
可以手动指定bean,它有2个属性分别是name和type，使用name属性，则使用byName的自动注入，而使用type属性时则使用byType自动注入。<br>
@Resource(name=”bean名字”)<br>
或<br>
@Resource(type=”bean的class”)<br>
这个注解是属于J2EE的，减少了与spring的耦合。</p>
<h1 id="spring-aop">Spring AOP</h1>
<h2 id="基本概念">基本概念</h2>
<p>在 spring 中 Aspect 通过<code>@Aspect</code>、<code>@Pointcut</code>和一系列 advice（<code>@Before</code>、<code>@after</code>、<code>@afterReturning</code>、<code>@Around</code>）组成。</p>
<ul>
<li><code>@Aspect</code> 切面，声明当前 class 为一个切面</li>
<li><code>@Pointcut</code> 切入点，通过 execution 表达式描述切入规则，</li>
<li>advice 通知，定义了切面是什么以及何时使用。</li>
<li>advice 中还包含了 连接点（joinpoint）</li>
<li>weave 织入，将切面应用到目标对象并导致代理对象创建的过程</li>
<li>introduction 引入，在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段</li>
</ul>
<h2 id="advice类型">advice类型</h2>
<h3 id="before">@Before</h3>
<p>前置通知（Before advice）：在某连接点（JoinPoint）——被切入代码（类或者方法）之前执行的通知，但这个通知不能阻止连接点前的执行。因为<code>@Before</code> 注解的方法入参不能传 ProceedingJoinPoint，而只能传入 JoinPoint。而从 aop 走到核心代码就是通过调用 ProceedingJionPoint 的 proceed()方法。而 JoinPoint 没有这个方法。<br>
这里牵扯区别这两个类：Proceedingjoinpoint 继承了 JoinPoint 。是在 JoinPoint 的基础上暴露出 proceed 这个方法。proceed 很重要，这个是 aop 代理链执行的方法。暴露出这个方法，就能支持 aop:around 这种切面（而其他的几种切面只需要用到 JoinPoint，这跟切面类型有关）， 能决定是否走代理链还是走自己拦截的其他逻辑。</p>
<h3 id="after">@After</h3>
<p>后通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p>
<h3 id="afterreturning">@AfterReturning</h3>
<p>返回后通知（After return advice）：在某连接点正常完成后执行的通知，不包括抛出异常的情况。</p>
<h3 id="around">@Around</h3>
<p>环绕通知（Around advice）：包围一个连接点的通知，类似 Web 中 Servlet 规范中的 Filter 的 doFilter 方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。这时 aop 的最重要的，最常用的注解。用这个注解的方法入参传的是 ProceedingJionPoint pjp，可以决定当前线程能否进入核心方法中——通过调用 <code>pjp.proceed();</code></p>
<h3 id="afterthrowing">@AfterThrowing</h3>
<p>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</p>
<h2 id="advice-注解的执行先后顺序">advice 注解的执行先后顺序</h2>
<p>单个执行：<br>
<img src="https://rayzhang13.github.io/post-images/1624189595455.png" alt="" loading="lazy"><br>
多个切面执行：<br>
<img src="https://rayzhang13.github.io/post-images/1624189647566.png" alt="" loading="lazy"></p>
<p>其实我们可以将aop视作同心圆<br>
<img src="https://rayzhang13.github.io/post-images/1624189778815.png" alt="" loading="lazy"><br>
spring aop就是一个同心圆，要执行的方法为圆心，最外层的order最小。从最外层按照AOP1、AOP2的顺序依次执行doAround方法，doBefore方法。然后执行method方法，最后按照AOP2、AOP1的顺序依次执行doAfter、doAfterReturn方法。也就是说对多个AOP来说，先before的，一定后after。<br>
如果我们要在同一个方法事务提交后执行自己的AOP，那么把事务的AOP order设置为2，自己的AOP order设置为1，然后在doAfterReturn里边处理自己的业务逻辑。<br>
order越小越是最先执行，但更重要的是最先执行的最后结束。</p>
<h2 id="代码实例">代码实例</h2>
<p>如下为Ascpect类</p>
<pre><code class="language-java">@Aspect
@Component
@Log4j2
public class LogAspect {
    @Pointcut(&quot;execution(* com.ray.blog.web.*.*(..))&quot;)
    //表示匹配 所有返回类型（*含义） 下的com.ray.web下面的所有类（.*含义）
    //匹配所有方法（.*）任何参数（(..)含义）
    public void log(){}

    @Before(&quot;log()&quot;)
    public void doBefore(JoinPoint joinPoint){
        log.info(&quot;-----------doBefore-------------&quot;);
    }
    @After(&quot;log()&quot;)
    public void doAfter(){
        log.info(&quot;-------------doAfter-----------------&quot;);
    }
    @AfterReturning(returning = &quot;result&quot;, pointcut = &quot;log()&quot;)
    public void doAfterReturn(Object result){
        log.info(&quot;Result: {}&quot;, result);
    }
}
</code></pre>
<p>如下为对应的Servlet Controller类：</p>
<pre><code class="language-java">@Controller
public class IndexController {
    @GetMapping(&quot;/&quot;)
    public String index(){
        System.out.println(&quot;-----------index-----------&quot;);
        return &quot;index&quot;;
    }
}
</code></pre>
<p>访问<code>127.0.0.1:8080</code>得到如下日志：</p>
<pre><code class="language-bash">20:00:22.415 [http-nio-8080-exec-1] INFO  com.ray.blog.aspect.LogAspect - -----------doBefore-------------
-----------index-----------
20:00:22.421 [http-nio-8080-exec-1] INFO  com.ray.blog.aspect.LogAspect - Result: index
20:00:22.421 [http-nio-8080-exec-1] INFO  com.ray.blog.aspect.LogAspect - -------------doAfter-----------------
</code></pre>
<p>验证了aop切面的运行顺序</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode Weekly Contest Round 246]]></title>
        <id>https://rayzhang13.github.io/post/leetcode-weekly-contest-round-246/</id>
        <link href="https://rayzhang13.github.io/post/leetcode-weekly-contest-round-246/">
        </link>
        <updated>2021-06-20T04:53:26.000Z</updated>
        <summary type="html"><![CDATA[<p><img src="https://rayzhang13.github.io/post-images/1624365854328.png" alt="" loading="lazy"><br>
久违的AK，题目不难，贴完代码就跑（狗头）<br>
什么叫狗屎运啊（战术后仰）</p>
]]></summary>
        <content type="html"><![CDATA[<p><img src="https://rayzhang13.github.io/post-images/1624365854328.png" alt="" loading="lazy"><br>
久违的AK，题目不难，贴完代码就跑（狗头）<br>
什么叫狗屎运啊（战术后仰）</p>
<!-- more -->
<h1 id="t1-5788-字符串中的最大奇数">T1 <a href="https://leetcode-cn.com/problems/largest-odd-number-in-string/">5788. 字符串中的最大奇数</a></h1>
<h2 id="题目">题目</h2>
<p>给你一个字符串 num ，表示一个大整数。请你在字符串 num 的所有 <strong>非空子字符串</strong> 中找出 <strong>值最大的奇数</strong> ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 &quot;&quot; 。<br>
<strong>子字符串</strong> 是字符串中的一个连续的字符序列。</p>
<blockquote>
<p>示例 1：<br>
输入：num = &quot;52&quot;<br>
输出：&quot;5&quot;<br>
解释：非空子字符串仅有 &quot;5&quot;、&quot;2&quot; 和 &quot;52&quot; 。&quot;5&quot; 是其中唯一的奇数。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：num = &quot;4206&quot;<br>
输出：&quot;&quot;<br>
解释：在 &quot;4206&quot; 中不存在奇数。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：num = &quot;35427&quot;<br>
输出：&quot;35427&quot;<br>
解释：&quot;35427&quot; 本身就是一个奇数。</p>
</blockquote>
<blockquote>
<p>提示：<br>
1 &lt;= num.length &lt;= 10^5<br>
num 仅由数字组成且不含前导零</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>贪心，没啥悬念，找到最后一个奇数位，从头到这个位置能确保长度最大化，必为最大奇数</p>
<pre><code class="language-java">class Solution {
    public String largestOddNumber(String num) {
        int len = num.length();
        int flag = -1;
        for(int i = 0; i &lt; len; i++){
            if((int)(num.charAt(i) - '0') % 2 == 1) flag = i;
        }
        if(flag == -1) return &quot;&quot;;
        else return num.substring(0, flag + 1);
    }
}
</code></pre>
<h1 id="t2-5789-你完成的完整对局数">T2 <a href="https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played/">5789. 你完成的完整对局数</a></h1>
<h2 id="题目-2">题目</h2>
<p>一款新的在线电子游戏在近期发布，在该电子游戏中，以 <strong>刻钟</strong> 为周期规划若干时长为 <strong>15 分钟</strong> 的游戏对局。这意味着，在 <code>HH:00</code>、<code>HH:15</code>、<code>HH:30</code> 和 <code>HH:45</code> ，将会开始一个新的对局，其中 <code>HH</code> 用一个从 <code>00</code> 到 <code>23</code> 的整数表示。游戏中使用 <strong>24 小时制的时钟</strong> ，所以一天中最早的时间是 <code>00:00</code> ，最晚的时间是 <code>23:59</code> 。<br>
给你两个字符串 <code>startTime</code> 和 <code>finishTime</code> ，均符合 <code>&quot;HH:MM&quot;</code> 格式，分别表示你 <strong>进入</strong> 和 <strong>退出</strong> 游戏的确切时间，请计算在整个游戏会话期间，你完成的 <strong>完整对局的对局数</strong> 。<br>
例如，如果 <code>startTime = &quot;05:20&quot;</code> 且 <code>finishTime = &quot;05:59&quot;</code> ，这意味着你仅仅完成从 <code>05:30</code> 到 <code>05:45</code> 这一个完整对局。而你没有完成从 <code>05:15</code> 到 <code>05:30</code> 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 <code>05:45</code> 到 <code>06:00</code> 的完整对局，因为你是在对局结束前退出的游戏。<br>
如果 <code>finishTime</code> 早于 <code>startTime</code> ，这表示你玩了个通宵（也就是从 <code>startTime</code> 到午夜，再从午夜到 <code>finishTime</code>）。</p>
<p>假设你是从 <code>startTime</code> 进入游戏，并在 <code>finishTime</code> 退出游戏，请计算并返回你完成的 <strong>完整对局的对局数</strong> 。</p>
<blockquote>
<p>示例 1：<br>
输入：startTime = &quot;12:01&quot;, finishTime = &quot;12:44&quot;<br>
输出：1<br>
解释：你完成了从 12:15 到 12:30 的一个完整对局。<br>
你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。<br>
你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：startTime = &quot;20:00&quot;, finishTime = &quot;06:00&quot;<br>
输出：40<br>
解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。<br>
16 + 24 = 40</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：startTime = &quot;00:00&quot;, finishTime = &quot;23:59&quot;<br>
输出：95<br>
解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。</p>
</blockquote>
<blockquote>
<p>提示：<br>
startTime 和 finishTime 的格式为 HH:MM<br>
00 &lt;= HH &lt;= 23<br>
00 &lt;= MM &lt;= 59<br>
startTime 和 finishTime 不相等</p>
</blockquote>
<h2 id="题解-2">题解</h2>
<p>基本思路：考虑将开始时刻修正为首轮开始的有效时刻，即<code>00</code> <code>15</code> <code>30</code> <code>45</code>时刻，随后计算修正后的总时间，将总时间除以15即可得到有效场次</p>
<p>我们先计算修正前的时间，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">res &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>即 <code>startTime</code> 大于 <code>finishTime</code>，我们认为对局将跨越午夜，故加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn><mo>∗</mo><mn>60</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">24 * 60 min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>即一天的时间。随后我们对开始时间进行修正，从总时间中扣除余量</p>
<p>在此需要注意两个操作的顺序，切勿颠倒</p>
<p>代码如下：</p>
<pre><code class="language-java">class Solution {
    public int numberOfRounds(String startTime, String finishTime) {
        int s_hour = Integer.parseInt(startTime.substring(0, 2));
        int s_minute = Integer.parseInt(startTime.substring(3, 5));
        int f_hour = Integer.parseInt(finishTime.substring(0, 2));
        int f_minute = Integer.parseInt(finishTime.substring(3, 5));
        int res = f_minute - s_minute + 60 * (f_hour - s_hour);
        if(res &lt; 0) res += 24 * 60;
        if(s_minute == 0){
            
        }
        else if(s_minute &lt;= 15){
            res -= 15 - s_minute;
        }
        else if(s_minute &lt;= 30){
            res -= 30 - s_minute;
        }
        else if(s_minute &lt;= 45){
            res -= 45 - s_minute;
        }
        else if(s_minute &lt;= 60){
            res -= 60 - s_minute;
        }
        return res &gt;= 0 ? res / 15: 0;
    }
}
</code></pre>
<h1 id="t3-5791-统计子岛屿">T3 <a href="https://leetcode-cn.com/problems/count-sub-islands/">5791. 统计子岛屿</a></h1>
<h2 id="题目-3">题目</h2>
<p>给你两个 <code>m x n</code> 的二进制矩阵 <code>grid1</code> 和 <code>grid2</code> ，它们只包含 <code>0</code> （表示水域）和 <code>1</code> （表示陆地）。一个 <strong>岛屿</strong> 是由 <strong>四个方向</strong> （水平或者竖直）上相邻的 <code>1</code> 组成的区域。任何矩阵以外的区域都视为水域。<br>
如果 <code>grid2</code> 的一个岛屿，被 <code>grid1</code> 的一个岛屿 <strong>完全</strong> 包含，也就是说 <code>grid2</code> 中该岛屿的每一个格子都被 <code>grid1</code> 中同一个岛屿完全包含，那么我们称 <code>grid2</code> 中的这个岛屿为 <strong>子岛屿</strong> 。<br>
请你返回 <code>grid2</code> 中 <strong>子岛屿</strong> 的 <strong>数目</strong> 。</p>
<blockquote>
<p>示例 1：<br>
<img src="https://rayzhang13.github.io/post-images/1624166493940.png" alt="" loading="lazy"><br>
输入：<code>grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]]</code>, <code>grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]</code><br>
输出：3<br>
解释：如上图所示，左边为 <code>grid1</code> ，右边为 <code>grid2</code> 。<br>
<code>grid2</code> 中标红的 <code>1</code> 区域是子岛屿，总共有 3 个子岛屿。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
<img src="https://rayzhang13.github.io/post-images/1624166520829.png" alt="" loading="lazy"><br>
输入：<code>grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]</code>, <code>grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]</code><br>
输出：2<br>
解释：如上图所示，左边为 <code>grid1</code> ，右边为 <code>grid2</code> 。<br>
<code>grid2</code> 中标红的 <code>1</code> 区域是子岛屿，总共有 2 个子岛屿。</p>
</blockquote>
<blockquote>
<p>提示：<br>
m == grid1.length == grid2.length<br>
n == grid1[i].length == grid2[i].length<br>
1 &lt;= m, n &lt;= 500<br>
<code>grid1[i][j]</code> 和 <code>grid2[i][j]</code> 都要么是 0 要么是 1 。</p>
</blockquote>
<h2 id="题解-3">题解</h2>
<p>非常常规的遍历，BFS和DFS在这道题目中都可以，全看阅读理解<br>
grid2按块遍历，全部抹成0，过程中和grid1比较，如果grid1有0，这块就不算</p>
<p>代码如下：</p>
<pre><code class="language-java">class Solution {
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int rows = grid1.length;
        int cols = grid1[0].length;
        int cnt = 0;
        int[] dir = new int[]{-1, 0, 1, 0, -1};
        for(int i = 0; i &lt; rows; i++){
            for(int j = 0; j &lt; cols; j++){
                boolean flag = true;
                if(grid2[i][j] == 1){
                    Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();
                    queue.offer(new int[]{i, j});
                    grid2[i][j] = 0;
                    while(!queue.isEmpty()){
                        int[] cur = queue.poll();
                        int x = cur[0], y = cur[1];
                        if(grid1[x][y] != 1){
                            flag = false;
                        }
                        for(int t = 0; t &lt; 4; t++){
                            int nx = x + dir[t], ny = y + dir[t + 1];
                            if(nx &gt;= 0 &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; cols &amp;&amp; grid2[nx][ny] == 1){
                                grid2[nx][ny] = 0;
                                queue.offer(new int[]{nx, ny});
                            }
                        }
                    }
                }
                else continue;
                if(flag) {
                    cnt++;
                }
            }
        }
        return cnt;
    }
}
</code></pre>
<h1 id="t4-5790-查询差绝对值的最小值">T4 <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-queries/">5790. 查询差绝对值的最小值</a></h1>
<h2 id="题目-4">题目</h2>
<p>一个数组 a 的 <strong>差绝对值的最小值</strong> 定义为：<code>0 &lt;= i &lt; j &lt; a.length</code> 且 <code>a[i] != a[j]</code> 的 <code>|a[i] - a[j]|</code> 的 <strong>最小值</strong>。如果 a 中所有元素都 <strong>相同</strong> ，那么差绝对值的最小值为 <code>-1</code> 。<br>
比方说，数组 <code>[5,2,3,7,2]</code> 差绝对值的最小值是 <code>|2 - 3| = 1</code> 。注意答案不为 <code>0</code> ，因为 <code>a[i]</code> 和 <code>a[j]</code> 必须不相等。<br>
给你一个整数数组 <code>nums</code> 和查询数组 <code>queries</code> ，其中 <code>queries[i] = [li, ri]</code> 。对于每个查询 <code>i</code> ，计算 <strong>子数组</strong> <code>nums[li...ri]</code> 中 <strong>差绝对值的最小值</strong> ，子数组 <code>nums[li...ri]</code> 包含 <code>nums</code> 数组（下标从 <strong>0</strong> 开始）中下标在 <code>li</code> 和 <code>ri</code> 之间的所有元素（包含 <code>li</code> 和 <code>ri</code> 在内）。<br>
请你返回 <code>ans</code> 数组，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。<br>
<strong>子数组</strong> 是一个数组中连续的一段元素。<br>
<code>|x|</code> 的值定义为：</p>
<ul>
<li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li>
<li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li>
</ul>
<blockquote>
<p>示例 1：<br>
输入：<code>nums = [1,3,4,8]</code>, <code>queries = [[0,1],[1,2],[2,3],[0,3]]</code><br>
输出：<code>[2,1,4,1]</code><br>
解释：查询结果如下：<br>
<code>queries[0] = [0,1]</code>：子数组是 <code>[1,3]</code> ，差绝对值的最小值为 <code>|1-3| = 2</code> 。<br>
<code>queries[1] = [1,2]</code>：子数组是 <code>[3,4]</code> ，差绝对值的最小值为 <code>|3-4| = 1</code> 。<br>
<code>queries[2] = [2,3]</code>：子数组是 <code>[4,8]</code> ，差绝对值的最小值为 <code>|4-8| = 4</code> 。<br>
<code>queries[3] = [0,3]</code>：子数组是 <code>[1,3,4,8]</code> ，差的绝对值的最小值为 <code>|3-4| = 1</code> 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：<code>nums = [4,5,2,2,7,10]</code>, <code>queries = [[2,3],[0,2],[0,5],[3,5]]</code><br>
输出：<code>[-1,1,1,3]</code><br>
解释：查询结果如下：<br>
<code>queries[0] = [2,3]</code>：子数组是 <code>[2,2]</code> ，差绝对值的最小值为 <code>-1</code> ，因为所有元素相等。<br>
<code>queries[1] = [0,2]</code>：子数组是 <code>[4,5,2]</code> ，差绝对值的最小值为 <code>|4-5| = 1</code> 。<br>
<code>queries[2] = [0,5]</code>：子数组是 <code>[4,5,2,2,7,10]</code> ，差绝对值的最小值为 <code>|4-5| = 1</code> 。<br>
<code>queries[3] = [3,5]</code>：子数组是 <code>[2,7,10]</code> ，差绝对值的最小值为 <code>|7-10| = 3</code> 。<br>
 <br>
提示：<br>
<code>2 &lt;= nums.length &lt;= 10^5</code><br>
<code>1 &lt;= nums[i] &lt;= 100</code><br>
<code>1 &lt;= queries.length &lt;= 2 * 10^4</code><br>
<code>0 &lt;= li &lt; ri &lt; nums.length</code></p>
</blockquote>
<h2 id="题解-4">题解</h2>
<p>这道题初看很吓人，关键点在于<code>1 &lt;= nums[i] &lt;= 100</code>，由此我们想到<strong>前缀和</strong>，创建一个数组<code>new int[len][101]</code>，在每个位置用一个<strong>100长度的数组</strong> 表示 100以内各个数字从头开始出现的个数，当我们要计算区间时，只需要抽出 对应的两条100长度的数组 相减 即可获得 <strong>此区间内的各数出现次数</strong><br>
随后我们只需要在生成的100长度的数组中，计算非0元素间的最短距离</p>
<p>代码如下：</p>
<pre><code class="language-java">class Solution {
    public int[] minDifference(int[] nums, int[][] queries) {
        int len = nums.length;
        int[][] arr = new int[len][101];
        for(int i = 0; i &lt; len; i++){
            for(int j = 0; j &lt; 101; j++){
                arr[i][j] = (i &gt; 0) ? arr[i - 1][j] : 0;
            }
            arr[i][nums[i]] = (i &gt; 0 ? arr[i - 1][nums[i]] : 0) + 1;
        }
        int[] res = new int[queries.length];
        int a = 0;
        for(int[] query: queries){
            int[] tmp = new int[101];
            for(int i = 0; i &lt; 101; i++){
                tmp[i] = arr[query[1]][i] - (query[0] == 0 ? 0 : (arr[query[0] - 1][i]));
            }
            int prev = -1;
            int min = Integer.MAX_VALUE;
            for(int i = 1; i &lt;= 100; i++){
                if(tmp[i] != 0){
                    if(prev == -1){
                        prev = i;
                        continue;
                    }
                    else{
                        min = Math.min(min, i - prev);
                        prev = i;
                    }
                }
            }
            if(min == Integer.MAX_VALUE &amp;&amp; prev != -1) res[a++] = -1;
            else res[a++] = min;
        }
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode Weekly Contest Round 244]]></title>
        <id>https://rayzhang13.github.io/post/leetcode-weekly-contest-round-244/</id>
        <link href="https://rayzhang13.github.io/post/leetcode-weekly-contest-round-244/">
        </link>
        <updated>2021-06-06T06:04:09.000Z</updated>
        <summary type="html"><![CDATA[<p>暴露了自己<strong>超级弟弟</strong>的事实，不管怎么说，先来梳理一下题目吧<br>
<img src="https://rayzhang13.github.io/post-images/1622959531798.png" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>暴露了自己<strong>超级弟弟</strong>的事实，不管怎么说，先来梳理一下题目吧<br>
<img src="https://rayzhang13.github.io/post-images/1622959531798.png" alt="" loading="lazy"></p>
<!-- more -->
<h1 id="t1-5776-判断矩阵经轮转后是否一致">T1 <a href="https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/">5776. 判断矩阵经轮转后是否一致</a></h1>
<h2 id="题目">题目</h2>
<p>给你两个大小为 n x n 的二进制矩阵 mat 和 target 。现 <strong>以 90 度顺时针轮转</strong> 矩阵 mat 中的元素 <strong>若干次</strong> ，如果能够使 mat 与 target 一致，返回 true ；否则，返回 false 。</p>
<blockquote>
<p>示例 1：<br>
<img src="https://rayzhang13.github.io/post-images/1622959783068.png" alt="" loading="lazy"><br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo>]</mo><mo separator="true">,</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">mat = [[0,1],[1,0]], target = [[1,0],[0,1]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><br>
输出：true<br>
解释：顺时针轮转 90 度一次可以使 mat 和 target 一致。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
<img src="https://rayzhang13.github.io/post-images/1622959818918.png" alt="" loading="lazy"><br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>]</mo><mo separator="true">,</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">mat = [[0,1],[1,1]], target = [[1,0],[0,1]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><br>
输出：false<br>
解释：无法通过轮转矩阵中的元素使 equal 与 target 一致。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
<img src="https://rayzhang13.github.io/post-images/1622959926137.png" alt="" loading="lazy"><br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>]</mo><mo separator="true">,</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><br>
输出：true<br>
解释：顺时针轮转 90 度两次可以使 mat 和 target 一致。<br>
 <br>
提示：<br>
n == mat.length == target.length<br>
n == <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">mat[i].length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span> == <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">target[i].length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span><br>
1 &lt;= n &lt;= 10<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">mat[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">target[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 不是 0 就是 1</p>
</blockquote>
<h2 id="题解">题解</h2>
<p>上来直接贴代码</p>
<pre><code class="language-java">class Solution {
    public boolean findRotation(int[][] mat, int[][] target) {
        for(int i = 0; i &lt; 4; i++){
            mat = change(mat);
            if(equals(mat, target)) return true;
        }
        return false;
    }
    public int[][] change(int[][] matrix){
		int[][] temp=new int[matrix[0].length][matrix.length];
		int dst = matrix.length - 1;
		for(int i = 0; i &lt; matrix.length; i++, dst--){
			for(int j = 0; j &lt; matrix[0].length; j++){
				temp[j][dst] = matrix[i][j];
			}
		}
		return temp;
	}
    public boolean equals(int[][] arr1, int[][] arr2){
        int rows = arr1.length;
        int cols = arr1[0].length;
        for(int i = 0; i &lt; rows; i++){
            for(int j = 0; j &lt; cols; j++){
                if(arr1[i][j] != arr2[i][j]) return false;
            }
        }
        return true;
    }
}
</code></pre>
<p>翻转matrix，每次翻转完比较即可</p>
<h1 id="t2-5777-使数组元素相等的减少操作次数">T2 <a href="https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal/">5777. 使数组元素相等的减少操作次数</a></h1>
<h2 id="题目-2">题目</h2>
<p>给你一个整数数组 nums ，你的目标是令 nums 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p>
<p>找出 nums 中的 <strong>最大</strong> 值。记这个值为 largest 并取其下标 i <strong>（下标从 0 开始计数）</strong>。如果有多个元素都是最大值，则取最小的 i 。<br>
找出 nums 中的 <strong>下一个最大</strong> 值，这个值 严格小于 largest ，记为 nextLargest 。<br>
将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 减少到 nextLargest 。<br>
返回使 nums 中的所有元素相等的操作次数。</p>
<blockquote>
<p>示例 1：<br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [5,1,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span><br>
输出：3<br>
解释：需要 3 次操作使 nums 中的所有元素相等：</p>
<ul>
<li>largest = 5 下标为 0 。nextLargest = 3 。将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 减少到 3 。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>3</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [3,1,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span></li>
<li>largest = 3 下标为 0 。nextLargest = 1 。将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 减少到 1 。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [1,1,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span></li>
<li>largest = 3 下标为 2 。nextLargest = 1 。将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 减少到 1 。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [1,1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>
</ul>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [1,1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><br>
输出：0<br>
解释：nums 中的所有元素已经是相等的。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [1,1,2,2,3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span><br>
输出：4<br>
解释：需要 4 次操作使 nums 中的所有元素相等：</p>
<ul>
<li>largest = 3 下标为 4 。nextLargest = 2 。将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 减少到 2 。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [1,1,2,2,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></li>
<li>largest = 2 下标为 2 。nextLargest = 1 。将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> 减少到 1 。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [1,1,1,2,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></li>
<li>largest = 2 下标为 3 。nextLargest = 1 。将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>3</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span></span></span></span> 减少到 1 。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [1,1,1,1,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></li>
<li>largest = 2 下标为 4 。nextLargest = 1 。将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 减少到 1 。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums = [1,1,1,1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><br>
 <br>
提示：<br>
1 &lt;= nums.length &lt;= 5 * 10^4<br>
1 &lt;= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> &lt;= 5 * 10^4</li>
</ul>
</blockquote>
<h2 id="题解-2">题解</h2>
<p>看在数据量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">5*10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>的情况下，请勿使用下方类似的直接模拟，除非你想喜提一发TLE</p>
<pre><code class="language-java">class Solution {
    public int reductionOperations(int[] nums) {
        TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; nums[o1] != nums[o2] ? nums[o2] - nums[o1]: o1 - o2);
        int len = nums.length;
        for(int i = 0; i &lt; len; i++){
            set.add(nums[i]);
            pq.offer(i);
        }
        int cnt = 0;
        while(!pq.isEmpty()){
            int cur = pq.poll();
            int val = nums[cur];
            Integer tmp = set.lower(val);
            if(tmp == null) return cnt;
            nums[cur] = tmp;
            pq.offer(cur);
            cnt++;
        }
        return cnt;
    }
}
</code></pre>
<p>静下心来仔细思考，我们想到数组的操作实际上是有规律可循的，每一轮的若干操作都会将<strong>最高梯度</strong>削平并入<strong>第二高梯度</strong>，而这轮的操作数量记为最高梯度的元素个数。<br>
随后第二高梯度成为最高梯度，数量加入了之前的梯度，继续此类操作，直到只剩最后一个梯度（即所有元素都被削成数组最小值），该梯度的高度为数组最小值<br>
代码如下：</p>
<pre><code class="language-java">class Solution {
    public int reductionOperations(int[] nums) {
        TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((o1, o2) -&gt; o2 - o1);
        //将map内部key由大到小排序
        int len = nums.length;
        for(int i = 0; i &lt; len; i++){
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        }
        int res = 0;
        int cnt = 0;
        for(int x: map.keySet()){//由大到小遍历key
            cnt += map.get(x); //cnt表示当前梯度的元素总数量（由之前的不断累加而来）
            res += cnt;
        }
        res -= cnt;//一不小心扣掉的最后一个梯度要还回来
        return res;
    }
}
</code></pre>
<h1 id="t3-5778-使二进制字符串字符交替的最少反转次数">T3 <a href="https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/">5778. 使二进制字符串字符交替的最少反转次数</a></h1>
<h2 id="题目-3">题目</h2>
<p>给你一个二进制字符串 s 。你可以按任意顺序执行以下两种操作任意次：</p>
<p><strong>类型 1 ：删除</strong> 字符串 s 的第一个字符并将它 <strong>添加</strong> 到字符串结尾。<br>
<strong>类型 2 ：选择</strong> 字符串 s 中任意一个字符并将该字符 <strong>反转</strong> ，也就是如果值为 '0' ，则反转得到 '1' ，反之亦然。<br>
请你返回使 s 变成 <strong>交替</strong> 字符串的前提下， <strong>类型 2</strong> 的 <strong>最少</strong> 操作次数 。</p>
<p>我们称一个字符串是 <strong>交替</strong> 的，需要满足任意相邻字符都不同。<br>
比方说，字符串 &quot;010&quot; 和 &quot;1010&quot; 都是交替的，但是字符串 &quot;0100&quot; 不是。</p>
<blockquote>
<p>示例 1：<br>
输入：s = &quot;111000&quot;<br>
输出：2<br>
解释：执行第一种操作两次，得到 s = &quot;100011&quot; 。<br>
然后对第三个和第六个字符执行第二种操作，得到 s = &quot;101010&quot; 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：s = &quot;010&quot;<br>
输出：0<br>
解释：字符串已经是交替的。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：s = &quot;1110&quot;<br>
输出：1<br>
解释：对第二个字符执行第二种操作，得到 s = &quot;1010&quot; 。</p>
</blockquote>
<blockquote>
<p>提示：<br>
1 &lt;= s.length &lt;= 10^5<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 要么是 '0' ，要么是 '1'</p>
</blockquote>
<h2 id="题解-3">题解</h2>
<p>看到这道题我们首先可以想到将s进行拼串，使用 <code>String str = s + s</code> 来表示第一轮操作后的位移后的各种情况，随后移位和&quot;101010...&quot;或者&quot;01010101...&quot;数组进行匹配，但是我们也注意到一个问题<br>
位移共有<code>s.length()</code>种情况，而每次全串匹配又需要<code>s.length()</code>次操作，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>的数量级下会喜提一发TLE</p>
<p>代码如下：</p>
<pre><code class="language-java">class Solution {
    public int minFlips(String s) {
        String str = s + s;
        int res = Integer.MAX_VALUE;
        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();
        for(int i = 0; i &lt; s.length(); i++){
            sb1.append(i % 2 == 0 ? '0': '1');
            sb2.append(i % 2 == 1 ? '0': '1');
        }
        for(int i = 0; i &lt; s.length(); i++){
            int cnt1 = 0, cnt2 = 0;
            for(int j = 0; j &lt; s.length(); j++){
                if(str.charAt(i + j) != sb1.charAt(j)) cnt1++;
                if(str.charAt(i + j) != sb2.charAt(j)) cnt2++;
            }
            res = Math.min(cnt1, res);
            res = Math.min(cnt2, res);
        }
        return res;
    }
}
</code></pre>
<p>经过仔细思考，我们发现事情好想并没有那么简单，但是好像出现了转机</p>
<p>首先明确：将移位后的字符串和&quot;010101...&quot;或&quot;101010...&quot; Pattern匹配，我们可以等价为将移位前的&quot;01010...&quot;或&quot;101010...&quot;Pattern和原串进行匹配</p>
<ul>
<li>
<p>对于偶数长度的字符串，我们发现不论是否移位，其匹配规则某种程度上仍然满足原先条件。</p>
</li>
<li>
<p>例如101010-&gt;010101，010101-&gt;010101，不论第一种操作操作几次，原先的Pattern始终就是两种模式中的一种，我们只需要对原串进行&quot;01010101....&quot;或者&quot;10101010...&quot;匹配即可</p>
</li>
<li>
<p>而对于奇数长度串，情况就有了一些复杂</p>
</li>
<li>
<p>例如01 | 10101-&gt;10101 01，101 | 1010-&gt;1010 101我们发现原先的Pattern很明显的从某个位置被划开分成了两部分，左右各遵循不同的匹配模式</p>
</li>
<li>
<p>据此我们想到了需要拼串，需要分别求解两段区间各自匹配不同模式后不满足的数字的总数</p>
</li>
<li>
<p>据此我们想到了<strong>前缀和</strong>，将两种匹配模式和s串不匹配的数目以前缀和的方式存储起来，方便求解区间</p>
</li>
</ul>
<p>好啦差不多了，可以直接上代码了：<br>
对于奇数情况，我们维护cnt1 cnt2两个数组表示匹配不满足的前缀和，随后遍历区间分割线，将情况全部遍历，对于偶数直接给出最终结果即可</p>
<pre><code class="language-java">class Solution {
    public int minFlips(String s) {
        int len = s.length();
        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();
        for(int i = 0; i &lt; len; i++){
            sb1.append(i % 2 == 0? '0': '1');
            sb2.append(i % 2 == 0? '1': '0');
        }
        int[] cnt1 = new int[len];
        int[] cnt2 = new int[len];
        for(int i = 0; i &lt; len; i++){
            cnt1[i] = (i &gt; 0 ? cnt1[i - 1] : 0) + (s.charAt(i) == sb1.charAt(i)? 0: 1);
            cnt2[i] = (i &gt; 0 ? cnt2[i - 1] : 0) + (s.charAt(i) == sb2.charAt(i)? 0: 1);
        }
        int res = Math.min(cnt1[len - 1], cnt2[len - 1]);
        if(len % 2 == 1){
            for(int i = 0; i &lt; len; i++){
                res = Math.min(cnt1[i] + cnt2[len - 1] - cnt2[i], res);
                res = Math.min(cnt2[i] + cnt1[len - 1] - cnt1[i], res);
            }
            return res;
        }
        else return Math.min(cnt1[len - 1], cnt2[len - 1]);
    }
}
</code></pre>
<h1 id="t4-5779-装包裹的最小浪费空间">T4 <a href="https://leetcode-cn.com/problems/minimum-space-wasted-from-packaging/">5779. 装包裹的最小浪费空间</a></h1>
<h2 id="题目-4">题目</h2>
<p>给你 n 个包裹，你需要把它们装在箱子里，<strong>每个箱子装一个包裹</strong>。总共有 m 个供应商提供 <strong>不同尺寸</strong> 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 <strong>小于等于</strong> 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p>
<p>包裹的尺寸用一个整数数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 表示，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">packages[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 是第 i 个包裹的尺寸。供应商用二维数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">boxes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 表示，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">boxes[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 是第 j 个供应商提供的所有箱子尺寸的数组。</p>
<p>你想要选择 <strong>一个供应商</strong> 并只使用该供应商提供的箱子，使得 <strong>总浪费空间最小</strong> 。对于每个装了包裹的箱子，我们定义 <strong>浪费的</strong> 空间等于 箱子的尺寸 - 包裹的尺寸 。<strong>总浪费空间</strong> 为 <strong>所有</strong> 箱子中浪费空间的总和。</p>
<p>比方说，如果你想要用尺寸数组为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[4,8]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">]</span></span></span></span> 的箱子装下尺寸为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[2,3,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span> 的包裹，你可以将尺寸为 2 和 3 的两个包裹装入两个尺寸为 4 的箱子中，同时把尺寸为 5 的包裹装入尺寸为 8 的箱子中。总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。<br>
请你选择 <strong>最优</strong> 箱子供应商，使得 <strong>总浪费空间最小</strong> 。如果 <strong>无法</strong> 将所有包裹放入箱子中，请你返回 -1 。由于答案可能会 <strong>很大</strong> ，请返回它对 10^9 + 7 <strong>取余</strong> 的结果。</p>
<blockquote>
<p>示例 1：<br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo>]</mo><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>8</mn><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">packages = [2,3,5], boxes = [[4,8],[2,8]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><br>
输出：6<br>
解释：选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。<br>
总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo>]</mo><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><br>
输出：-1<br>
解释：没有箱子能装下尺寸为 5 的包裹。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi><mo>=</mo><mo>[</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo>]</mo><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>=</mo><mo>[</mo><mo>[</mo><mn>12</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>11</mn><mo separator="true">,</mo><mn>9</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>10</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>14</mn><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span><br>
输出：9<br>
解释：选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。<br>
总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。<br>
 <br>
提示：<br>
n == packages.length<br>
m == boxes.length<br>
1 &lt;= n &lt;= 10^5<br>
1 &lt;= m &lt;= 10^5<br>
1 &lt;= packages[i] &lt;= 10^5<br>
1 &lt;= boxes[j].length &lt;= 10^5<br>
1 &lt;= boxes[j][k] &lt;= 10^5<br>
sum(boxes[j].length) &lt;= 10^5<br>
boxes[j] 中的元素 <strong>互不相同</strong> 。</p>
</blockquote>
<h2 id="题解-4">题解</h2>
<p>直觉之下我们知道要求解<strong>浪费空间最小</strong>，关键在于在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">boxes[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>中取得比当前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">package[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>大的最小的值，那就是<strong>二分</strong>喽，思路没错，但是有很多小细节需要注意</p>
<p>首先根据题目答案可能很大需要对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>取余，但是在算法计算过程中我们却不能这么做，提前取余会影响大小的比较，取余只有最后一步得出答案时才能做。<br>
那么问题又来了<code>int</code>能不能存下我们当前的计算值呢？以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>数组为例，我们求和时，总量有可能达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">10^5*10^5=10^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>，是有可能发生溢出的，故我们先采用<code>long</code>保存答案</p>
<p>所以为了顺序和方便起见，我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">boxes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>数组内部一一进行排序，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">boxes[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>最大的盒子都存不下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>最大的包裹，说明不可行，直接跳过。<br>
否则我们进行下一步计算，现在又面临了一个新问题，我们是遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>数组，针对每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">packages[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>去寻找他的上界；还是遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">boxes[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>内部的元素，去查找他下面的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>呢？</p>
<p>如果我们遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>，会喜得一发TLE，代码如下：</p>
<pre><code class="language-java">class Solution {
    public int minWastedSpace(int[] packages, int[][] boxes) {
        int p_len = packages.length;
        int b_len = boxes.length;
        Arrays.sort(packages);
        long sum = 0L;
        long res = Long.MAX_VALUE;
        for(int x: packages) sum += x;
        for(int i = 0; i &lt; b_len; i++){
            int len = boxes[i].length;
            Arrays.sort(boxes[i]);
            if(boxes[i][len - 1] &lt; packages[p_len - 1]) continue;
            long total = 0L;
            for(int x: packages){ //遍历packages，二分搜索boxes[i]
                int lo = 0, hi = len - 1;
                int ans = -1;
                while(lo &lt;= hi){
                    int mid = lo + (hi - lo) / 2;
                    if(boxes[i][mid] &gt;= x){
                        ans = mid;
                        hi = mid - 1;
                    }
                    else lo = mid + 1;
                }
                //ans为大于boxes[i]中大于packages的最小下标
                total += boxes[i][ans];
            }
            res = Math.min(res, total - sum);
        }
        return res == Long.MAX_VALUE? -1: (int)(res % 1000000007);
    }
}
</code></pre>
<p>原因是什么呢？我们看到提示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">boxes[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 中的元素 <strong>互不相同</strong>，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>中的元素却是有可能重复的，我们根据遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>时一次只能求出一个对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">boxes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>的下标值，而且还多有重复，而如果我们遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>x</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">boxes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>数组，可能可以一次性在有序的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">packages</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>划分出一个专属的区间来，直接调用乘法总比一次一次加要来的省事还快</p>
<p>不多说了，上代码：</p>
<pre><code class="language-java">class Solution {
    public int minWastedSpace(int[] packages, int[][] boxes) {
        int p_len = packages.length;
        int b_len = boxes.length;
        Arrays.sort(packages);
        //System.out.println(Arrays.toString(packages));
        long sum = 0L;
        long res = Long.MAX_VALUE;
        for(int x: packages) sum += x;
        for(int i = 0; i &lt; b_len; i++){
            int len = boxes[i].length;
            Arrays.sort(boxes[i]);
            if(boxes[i][len - 1] &lt; packages[p_len - 1]) continue;
            long total = 0L;
            int tmp = 0;
            for(int x: boxes[i]){ //遍历boes[i]，二分查找packages
                int lo = tmp, hi = p_len - 1;
                int ans = -1;
                while(lo &lt;= hi){
                    int mid = lo + (hi - lo) / 2;
                    if(packages[mid] &lt;= x){
                        ans = mid;
                        lo = mid + 1;
                    }
                    else hi = mid - 1;
                }
                //ans为小于packages中小于boxes[i]的最大下标
                if(ans != -1) {
                    total += (long)(ans - tmp + 1) * (long)x; 
                    //boxes[i]当前的packages专属区间为[tmp, ans]
                    //此区间的元素都使用boxes[i]最佳
                    tmp = ans + 1;
                    //下一个区间一定和当前不重合，可以直接调节下一轮二分搜索的上界
                    //当然你不调整，那问题也不大，答案仍然正确
                }   
            }
            res = Math.min(res, total - sum);
        }
        return res == Long.MAX_VALUE? -1: (int)(res % 1000000007);
    }
}
</code></pre>
<p><img src="https://rayzhang13.github.io/post-images/1622965377360.png" alt="" loading="lazy"><br>
菜鸡本菜TLE到吐血</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于阻塞非阻塞与同步异步的理解]]></title>
        <id>https://rayzhang13.github.io/post/IO-modules/</id>
        <link href="https://rayzhang13.github.io/post/IO-modules/">
        </link>
        <updated>2021-06-05T05:08:49.000Z</updated>
        <summary type="html"><![CDATA[<p>一直对BIO、NIO、AIO模型理解不到位，特意整理了一下<br>
这里先拉几篇有意思的知乎做一下补充理解：<br>
<a href="https://www.zhihu.com/question/19732473/answer/20851256">链接</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>一直对BIO、NIO、AIO模型理解不到位，特意整理了一下<br>
这里先拉几篇有意思的知乎做一下补充理解：<br>
<a href="https://www.zhihu.com/question/19732473/answer/20851256">链接</a></p>
<!-- more -->
<p>“阻塞”与&quot;非阻塞&quot;与&quot;同步&quot;与“异步&quot;不能简单的从字面理解，提供一个从分布式系统角度的回答。<br>
阻塞和非阻塞描述的是进程/线程在进行I/O操作时的状态，而同步与异步描述的是进程/线程相互通信的方式。</p>
<h1 id="同步与异步">同步与异步</h1>
<p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。<br>
换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下&quot;，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<h1 id="阻塞与非阻塞">阻塞与非阻塞</h1>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong><br>
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>
还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<p>阻塞和非阻塞，应该描述的是一种状态，同步与非同步描述的是行为方式</p>
<h1 id="关于bio-nio-aio的理解">关于BIO、NIO、AIO的理解</h1>
<p>BIO同步阻塞：你打电话告诉老板你要买某书，老板拿起电话听你说完就去查书，没有说话，你什么也不知道，在得到任何结果之前，你一直拿着电话干等，你此时什么也干不了。30分钟后老板直接把书送到你家，这时你才挂断电话。每次电话你都要得得到结果（书到家）后你才挂断电话，这是同步。你一直拿着电话等结果，这是阻塞。</p>
<p>NIO同步非阻塞：你打电话告诉老板你要买某书，老板拿起电话后说“我不知道有没有货，现在去查”便挂了电话，又过了10分种你第二次打电话说你要买某书，老板拿起电话说完“还没有查到，你再等会儿”便挂断电话。挂断电话5分钟后老板查到有书，但并没有主动打电话告诉你。你再次等待10分钟后第三次电话老板问结果，老板说“书有了，我给你送到家”，你断挂电话。每次电话你都要得得到结果（去查-&gt;还没有查到-&gt;有货）后你才挂断电话，这是同步。你每隔10分钟打电话询问结果，这是非阻塞。这一天一夜，你时不时的离开电话去下片片，老板却一直在给你死查，期间老板也无法接听其他人的查询电话。</p>
<p>异步阻塞：你打电话过去问老板有没有某书，老板说“我不知道有没有货，现在去查，先挂了电话，有结果告诉你，你等我电话”就挂掉电话。等电话期间你什么也不干，老板主动给你发短信通知你结果书有了，5分钟后希望老板现在把书送来，你再次打电话让老板送书，老板马上送书上门。老板主动给你发短信，这是异步。等待老板的短信期间你什么也没干，这是阻塞。</p>
<p>AIO异步非阻塞：你打电话过去后问老板有没有某书，老板说“好的，有货我直接给你送上门”就挂掉电话。然后你想干嘛干嘛，等老板把书送到后你看书。等待老板主动给你送书上门，这是异步。挂了电话后你就想干嘛干嘛，这是非阻塞。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java线程池简单理解]]></title>
        <id>https://rayzhang13.github.io/post/thread-pool/</id>
        <link href="https://rayzhang13.github.io/post/thread-pool/">
        </link>
        <updated>2021-06-04T14:15:06.000Z</updated>
        <summary type="html"><![CDATA[<p>暂时快速梳理一下Java线程池（毕竟都是速成的）</p>
]]></summary>
        <content type="html"><![CDATA[<p>暂时快速梳理一下Java线程池（毕竟都是速成的）</p>
<!-- more -->
<h1 id="简介">简介</h1>
<p>由于主线程的诸多限制，像网络请求等一些耗时的操作我们必须在子线程中 运行。我们往往会通过 new Thread 来开启一个子线程，待子线程操作完成以后通过 Handler 切换到主线程中运行。这么以来我们无法管理我们所创建的子线程，并且无限制的创建子线程，它们相互之间竞争，很有可能由于占用过多资源而导致死机或者内存不足。所以在 Java 中为我们提供了线程池来管理我们所创建的线程。</p>
<h1 id="优势">优势</h1>
<ul>
<li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗;</li>
<li>提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行;</li>
<li>方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或内存不足等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率;</li>
<li>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单</li>
</ul>
<h1 id="线程池的创建">线程池的创建</h1>
<p>有以下三种：</p>
<ul>
<li>Executors.newCachedThreadPool()：无限线程池。</li>
</ul>
<pre><code class="language-java">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;(),
                                      threadFactory);
    }
</code></pre>
<ul>
<li>Executors.newFixedThreadPool(nThreads)：创建固定大小的线程池。</li>
</ul>
<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;(),
                                      threadFactory);
    }
</code></pre>
<ul>
<li>Executors.newSingleThreadExecutor()：创建单个线程的线程池。</li>
</ul>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory));
    }
</code></pre>
<p>线程池不允许使用Executors创建，而是通过ThreadPoolExecutor的方式，规避资源耗尽的风险</p>
<ul>
<li>Executors的弊端：</li>
</ul>
<ul>
<li>FixedThreadPool和SingleThreadPool:<br>
允许的请求队列长度为Integer.Max_VALUE，可能会堆积大量的请求，从而导致OOM（内存溢出）</li>
<li>CachedThreadPool和ScheduledThreadPool:<br>
允许的创建线程数目为Integer.Max_VALUE，可能会堆积大量的请求，从而导致OOM（内存溢出）</li>
</ul>
<h1 id="threadpoolexecutor七参数">ThreadPoolExecutor七参数</h1>
<h2 id="代码">代码</h2>
<p>Executors创建的线程池本质都是基于ThreadPoolExecutor</p>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }
</code></pre>
<h2 id="corepoolsize核心线程数">corePoolSize：核心线程数</h2>
<p>线程池维护的最小线程数量，核心线程创建后不会被回收（注意：设置allowCoreThreadTimeout=true&gt;后，空闲的核心线程超过存活时间也会被回收）。<br>
大于核心线程数的线程，在空闲时间超过keepAliveTime后会被回收。<br>
线程池刚创建时，里面没有一个线程，当调用 execute() 方法添加一个任务时，如果正在运行的线程数量小于corePoolSize，则马上创建新线程并运行这个任务。</p>
<h2 id="maximumpoolsize最大线程数">maximumPoolSize：最大线程数</h2>
<p>线程池允许创建的最大线程数量。<br>
当添加一个任务时，核心线程数已满，线程池还没达到最大线程数，并且没有空闲线程，工作队列已满的情况下，创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。</p>
<h2 id="keepalivetime空闲线程存活时间">keepAliveTime：空闲线程存活时间</h2>
<p>当一个可被回收的线程的空闲时间大于keepAliveTime，就会被回收。<br>
可被回收的线程：<br>
（1）设置allowCoreThreadTimeout=true的核心线程。<br>
（2）大于核心线程数的线程（非核心线程）。</p>
<h2 id="unit时间单位">unit：时间单位</h2>
<p>keepAliveTime的时间单位：</p>
<pre><code class="language-java">TimeUnit.NANOSECONDS
TimeUnit.MICROSECONDS
TimeUnit.MILLISECONDS // 毫秒
TimeUnit.SECONDS
TimeUnit.MINUTES
TimeUnit.HOURS
TimeUnit.DAYS
</code></pre>
<h2 id="workqueue工作队列">workQueue：工作队列</h2>
<p>新任务被提交后，会先添加到工作队列，任务调度时再从队列中取出任务。工作队列实现了BlockingQueue接口。<br>
JDK默认的工作队列有五种：<br>
（1）ArrayBlockingQueue 数组型阻塞队列：数组结构，初始化时传入大小，有界，FIFO，使用一个重入锁，默认使用非公平锁，入队和出队共用一个锁，互斥。<br>
（2）LinkedBlockingQueue 链表型阻塞队列：链表结构，默认初始化大小为Integer.MAX_VALUE，有界（近似无解），FIFO，使用两个重入锁分别控制元素的入队和出队，用Condition进行线程间的唤醒和等待。<br>
（3）SynchronousQueue 同步队列：容量为0，添加任务必须等待取出任务，这个队列相当于通道，不存储元素。<br>
（4）PriorityBlockingQueue 优先阻塞队列：无界，默认采用元素自然顺序升序排列。<br>
（5）DelayQueue 延时队列：无界，元素有过期时间，过期的元素才能被取出。</p>
<h2 id="threadfactory线程工厂">threadFactory：线程工厂</h2>
<p>创建线程的工厂，可以设定线程名、线程编号等。</p>
<pre><code class="language-java">public interface ThreadFactory {
    /**
     * Constructs a new {@code Thread}.  Implementations may also initialize
     * priority, name, daemon status, {@code ThreadGroup}, etc.
     *
     * @param r a runnable to be executed by new thread instance
     * @return constructed thread, or {@code null} if the request to
     *         create a thread is rejected
     */
    Thread newThread(Runnable r);
}
</code></pre>
<p>默认采用defaultThreadFactory</p>
<pre><code class="language-java">public static ThreadFactory defaultThreadFactory() {
        return new DefaultThreadFactory();
    }
</code></pre>
<pre><code class="language-java">private static class DefaultThreadFactory implements ThreadFactory {
        private static final AtomicInteger poolNumber = new AtomicInteger(1);
        private final ThreadGroup group;
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;

        DefaultThreadFactory() {
            SecurityManager s = System.getSecurityManager();
            group = (s != null) ? s.getThreadGroup() :
                                  Thread.currentThread().getThreadGroup();
            namePrefix = &quot;pool-&quot; +
                          poolNumber.getAndIncrement() +
                         &quot;-thread-&quot;;
        }

        public Thread newThread(Runnable r) {
            Thread t = new Thread(group, r,
                                  namePrefix + threadNumber.getAndIncrement(),
                                  0);
            if (t.isDaemon())
                t.setDaemon(false);
            if (t.getPriority() != Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            return t;
        }
    }
</code></pre>
<h2 id="handler拒绝策略">handler：拒绝策略</h2>
<p>当线程池线程数已满，并且工作队列达到限制，新提交的任务使用拒绝策略处理。可以自定义拒绝策略，拒绝策略需要实现RejectedExecutionHandler接口。<br>
JDK默认的拒绝策略有四种：<br>
（1）AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。<br>
（2）DiscardPolicy：丢弃任务，但是不抛出异常。可能导致无法发现系统的异常状态。<br>
（3）DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。<br>
（4）CallerRunsPolicy：由调用线程处理该任务。</p>
<h1 id="基本执行流程">基本执行流程</h1>
<figure data-type="image" tabindex="1"><img src="https://rayzhang13.github.io/post-images/1622822561168.png" alt="" loading="lazy"></figure>
<p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。<br>
首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：<br>
首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。<br>
如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。<br>
如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。<br>
如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。<br>
如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</p>
<h1 id="生命周期">生命周期</h1>
<p>1、RUNNING<br>
2、SHUNDOWN<br>
3、STOP<br>
4、TIDYING<br>
5、TERMINATED<br>
<img src="https://rayzhang13.github.io/post-images/1622823213188.png" alt="" loading="lazy"></p>
<p>这几个状态的转化关系为：<br>
1、调用shundown()方法线程池的状态由RUNNING——&gt;SHUTDOWN<br>
2、调用shutdowNow()方法线程池的状态由RUNNING——&gt;STOP<br>
3、当任务队列和线程池均为空的时候 线程池的状态由STOP/SHUTDOWN——–&gt;TIDYING<br>
4、当terminated()方法被调用完成之后，线程池的状态由TIDYING———-&gt;TERMINATED状态<br>
<img src="https://rayzhang13.github.io/post-images/1622823162874.png" alt="" loading="lazy"></p>
<p>shutdown()/shutdownNow()有着重要的区别：<br>
shutdown() 执行后停止接受新任务，会把队列的任务执行完毕。<br>
shutdownNow() 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。<br>
两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
]]></content>
    </entry>
</feed>